/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shepherd\": function() { return /* reexport default from dynamic */ shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL1Z1ZXh5Ly4vbGlicy9zaGVwaGVyZC9zaGVwaGVyZC5qcz83YTgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaGVwaGVyZCBmcm9tICdzaGVwaGVyZC5qcy9kaXN0L2pzL3NoZXBoZXJkJztcblxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcbiJdLCJuYW1lcyI6WyJTaGVwaGVyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*! shepherd.js 10.0.1 */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return target.propertyIsEnumerable(symbol);\n    }) : [];\n  }\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  } // Protects from prototype poisoning and unexpected merging up the prototype chain.\n\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx, once) {\n        if (once === void 0) {\n          once = false;\n        }\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n              handler = binding.handler,\n              once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }]);\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n    return self;\n  }\n\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref6 = step.options.advanceOn || {},\n      event = _ref6.event,\n      selector = _ref6.selector;\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step); // TODO: this should also bind/unbind on show/hide\n\n      var el;\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {// TODO\n      }\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n  }\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // and applies them to the HTMLElements such as popper and arrow\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n  function getBoundingClientRect(element, includeScale) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    var rect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (isHTMLElement(element) && includeScale) {\n      var offsetHeight = element.offsetHeight;\n      var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n      // Fallback to 1 in case both values are `0`\n\n      if (offsetWidth > 0) {\n        scaleX = round(rect.width) / offsetWidth || 1;\n      }\n      if (offsetHeight > 0) {\n        scaleY = round(rect.height) / offsetHeight || 1;\n      }\n    }\n    return {\n      width: rect.width / scaleX,\n      height: rect.height / scaleY,\n      top: rect.top / scaleY,\n      right: rect.right / scaleX,\n      bottom: rect.bottom / scaleY,\n      left: rect.left / scaleX,\n      x: rect.left / scaleX,\n      y: rect.top / scaleY\n    };\n  }\n\n  // means it doesn't take into account transforms.\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n    return false;\n  }\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument :\n    // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n    return (\n      // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot ||\n      // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || (\n      // DOM Element detected\n      isShadowRoot(element) ? element.host : null) ||\n      // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) ||\n    // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n    var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle(element);\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n      currentNode = currentNode.host;\n    }\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n  function withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n  }\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n  function arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options;\n    var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n      if (!arrowElement) {\n        return;\n      }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n      y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(x * dpr) / dpr || 0,\n      y: round(y * dpr) / dpr || 0\n    };\n  }\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n      offsetParent = offsetParent;\n      if (placement === top || (placement === left || placement === right) && variation === end) {\n        sideY = bottom;\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp];\n        y -= offsetY - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\n        sideX = right;\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp];\n        x -= offsetX - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n      var _Object$assign;\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n  function computeStyles(_ref5) {\n    var state = _ref5.state,\n      options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      variation: getVariation(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration,\n      isFixed: state.options.strategy === 'fixed'\n    };\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n  function effect(_ref) {\n    var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n    var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n    // can be obscured underneath it.\n    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n    // if it isn't open, so if this isn't available, the popper will be detected\n    // to overflow the bottom of the screen too early.\n\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n      // errors due to floating point numbers, so we need to check precision.\n      // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n      // Feature detection fails in mobile emulation mode in Chrome.\n      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n      // 0.001\n      // Fallback here: \"Not Safari\" userAgent\n\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  }\n\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n    return getScrollParent(getParentNode(node));\n  }\n\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList :\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n    return offsets;\n  }\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n    return overflowOffsets;\n  }\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n  function flip(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n      var _basePlacement = getBasePlacement(placement);\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases  research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\") break;\n      }\n    }\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n  function hide(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n        placement: placement\n      })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n  function offset(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n    var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n      name = _ref.name; // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n      mainAxis: tetherOffsetValue,\n      altAxis: tetherOffsetValue\n    } : Object.assign({\n      mainAxis: 0,\n      altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n      x: 0,\n      y: 0\n    };\n    if (!popperOffsets) {\n      return;\n    }\n    if (checkMainAxis) {\n      var _offsetModifierState$;\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = offset + overflow[mainSide];\n      var max$1 = offset - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = offset + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n      var _offsetModifierState$2;\n      var _mainSide = mainAxis === 'x' ? top : left;\n      var _altSide = mainAxis === 'x' ? bottom : right;\n      var _offset = popperOffsets[altAxis];\n      var _len = altAxis === 'y' ? 'height' : 'width';\n      var _min = _offset + overflow[_mainSide];\n      var _max = _offset - overflow[_altSide];\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n  function isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n  } // Returns the composite rect of an element relative to its offsetParent.\n  // Composite means it takes into account transforms as well as layout.\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' ||\n      // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent, true);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n      return pending;\n    };\n  }\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(setOptionsAction) {\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update  it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n          var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n            var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update  it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n            var noopFn = function noopFn() {};\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n      return instance;\n    };\n  }\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _getCenteredStylePopperModifier() {\n    return [{\n      name: 'applyStyles',\n      fn: function fn(_ref) {\n        var state = _ref.state;\n        Object.keys(state.elements).forEach(function (name) {\n          if (name !== 'popper') {\n            return;\n          }\n          var style = {\n            position: 'fixed',\n            left: '50%',\n            top: '50%',\n            transform: 'translate(-50%, -50%)'\n          };\n          var attributes = state.attributes[name] || {};\n          var element = state.elements[name];\n          Object.assign(element.style, style);\n          Object.keys(attributes).forEach(function (name) {\n            var value = attributes[name];\n            if (value === false) {\n              element.removeAttribute(name);\n            } else {\n              element.setAttribute(name, value === true ? '' : value);\n            }\n          });\n        });\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: false\n      }\n    }];\n  }\n  /**\n   * Generates a modifier for popper that will help focus the element after it has\n   * been rendered\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The focus after render modifier configuration object\n   */\n\n  function generateFocusAfterRenderModifier(step) {\n    return {\n      name: 'focusAfterRender',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn() {\n        setTimeout(function () {\n          if (step.el) {\n            var focusOptions = {\n              preventScroll: true\n            };\n            step.el.focus(focusOptions);\n          }\n        }, 300);\n      }\n    };\n  }\n  /**\n   * Generates the array of options for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The final Popper options object\n   */\n\n  function makeCenteredPopper(step) {\n    var centeredStylePopperModifier = _getCenteredStylePopperModifier();\n    var popperOptions = {\n      placement: 'top',\n      strategy: 'fixed',\n      modifiers: [generateFocusAfterRenderModifier(step)]\n    };\n    popperOptions = _extends({}, popperOptions, {\n      modifiers: Array.from(new Set([].concat(_toConsumableArray(popperOptions.modifiers), _toConsumableArray(centeredStylePopperModifier))))\n    });\n    return popperOptions;\n  }\n\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n  /**\n   * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n   * @param {Step} step The step instance\n   * @returns {{}|{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n    if (isFunction(returnOpts.element)) {\n      // Bind the callback to step so that it has access to the object, to enable running additional logic\n      returnOpts.element = returnOpts.element.call(step);\n    }\n    if (isString(returnOpts.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(returnOpts.element);\n      } catch (e) {// TODO\n      }\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n    return returnOpts;\n  }\n  /**\n   * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n   * alternative for the deprecated step.isCentered() method.\n   * @param resolvedAttachToOptions\n   * @returns {boolean}\n   */\n\n  function shouldCenterStep(resolvedAttachToOptions) {\n    if (resolvedAttachToOptions === undefined || resolvedAttachToOptions === null) {\n      return true;\n    }\n    return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `step.tooltip` as a Popper instance.\n   * @param {Step} step The step instance\n   */\n\n  function setupTooltip(step) {\n    if (step.tooltip) {\n      step.tooltip.destroy();\n    }\n    var attachToOptions = step._getResolvedAttachToOptions();\n    var target = attachToOptions.element;\n    var popperOptions = getPopperOptions(attachToOptions, step);\n    if (shouldCenterStep(attachToOptions)) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n    step.tooltip = createPopper(target, step.el, popperOptions);\n    step.target = attachToOptions.element;\n    return popperOptions;\n  }\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  /**\n   * Gets the `Popper` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n\n  function getPopperOptions(attachToOptions, step) {\n    var popperOptions = {\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          altAxis: true,\n          tether: false\n        }\n      }, generateFocusAfterRenderModifier(step)],\n      strategy: 'absolute'\n    };\n    if (shouldCenterStep(attachToOptions)) {\n      popperOptions = makeCenteredPopper(step);\n    } else {\n      popperOptions.placement = attachToOptions.on;\n    }\n    var defaultStepOptions = step.tour && step.tour.options && step.tour.options.defaultStepOptions;\n    if (defaultStepOptions) {\n      popperOptions = _mergeModifiers(defaultStepOptions, popperOptions);\n    }\n    popperOptions = _mergeModifiers(step.options, popperOptions);\n    return popperOptions;\n  }\n  function _mergeModifiers(stepOptions, popperOptions) {\n    if (stepOptions.popperOptions) {\n      var mergedPopperOptions = Object.assign({}, popperOptions, stepOptions.popperOptions);\n      if (stepOptions.popperOptions.modifiers && stepOptions.popperOptions.modifiers.length > 0) {\n        var names = stepOptions.popperOptions.modifiers.map(function (mod) {\n          return mod.name;\n        });\n        var filteredModifiers = popperOptions.modifiers.filter(function (mod) {\n          return !names.includes(mod.name);\n        });\n        mergedPopperOptions.modifiers = Array.from(new Set([].concat(_toConsumableArray(filteredModifiers), _toConsumableArray(stepOptions.popperOptions.modifiers))));\n      }\n      return mergedPopperOptions;\n    }\n    return popperOptions;\n  }\n  function noop() {}\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) tar[k] = src[k];\n    return tar;\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    node.parentNode.removeChild(node);\n  }\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n  function element(name) {\n    return document.createElement(name);\n  }\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function space() {\n    return text(' ');\n  }\n  function empty() {\n    return text('');\n  }\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n  var current_component;\n  function set_current_component(component) {\n    current_component = component;\n  }\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = Promise.resolve();\n  var update_scheduled = false;\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  // 1. All beforeUpdate callbacks, in order: parents before children\n  // 2. All bind:this callbacks, in reverse order: children before parents.\n  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n  //    for afterUpdates called during the initial onMount, which are called in\n  //    reverse order: children before parents.\n  // Since callbacks might update component values, which could trigger another\n  // call to flush(), the following steps guard against this:\n  // 1. During beforeUpdate, any updated components will be added to the\n  //    dirty_components array and will cause a reentrant call to flush(). Because\n  //    the flush index is kept outside the function, the reentrant call will pick\n  //    up where the earlier call left off and go through all dirty components. The\n  //    current_component value is saved and restored so that the reentrant call will\n  //    not interfere with the \"parent\" flush() call.\n  // 2. bind:this callbacks cannot trigger new flush() calls.\n  // 3. During afterUpdate, any updated components will NOT have their afterUpdate\n  //    callback called a second time; the seen_callbacks set, outside the flush()\n  //    function, guarantees this behavior.\n\n  var seen_callbacks = new Set();\n  var flushidx = 0; // Do *not* move this inside the flush() function\n\n  function flush() {\n    var saved_component = current_component;\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      while (flushidx < dirty_components.length) {\n        var component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) binding_callbacks.pop()(); // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n\n      for (var i = 0; i < render_callbacks.length; i += 1) {\n        var callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  var outroing = new Set();\n  var outros;\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n    outros = outros.p;\n  }\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n        for (var _key2 in n) {\n          if (!accounted_for[_key2]) {\n            update[_key2] = n[_key2];\n            accounted_for[_key2] = 1;\n          }\n        }\n        levels[i] = n;\n      } else {\n        for (var _key3 in o) {\n          accounted_for[_key3] = 1;\n        }\n      }\n    }\n    for (var _key4 in to_null_out) {\n      if (!(_key4 in update)) update[_key4] = undefined;\n    }\n    return update;\n  }\n  function create_component(block) {\n    block && block.c();\n  }\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      on_mount = _component$$$.on_mount,\n      on_destroy = _component$$$.on_destroy,\n      after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n      });\n    }\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n    if ($$.fragment !== null) {\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty) {\n    if (dirty === void 0) {\n      dirty = [-1];\n    }\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: null,\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update); // `false` as a special case of no DOM component\n\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.49.0 */\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value = /*label*/\n        ctx[3] ? /*label*/\n        ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat( /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat( /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''));\n        button.disabled = /*disabled*/\n        ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML = /*text*/\n        ctx[5];\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function( /*action*/\n            ctx[0])) /*action*/\n              ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref) {\n        var _ref7 = _slicedToArray(_ref, 1),\n          dirty = _ref7[0];\n        ctx = new_ctx;\n        if (dirty & /*text*/\n        32) button.innerHTML = /*text*/\n        ctx[5];\n        if (dirty & /*label*/\n        8 && button_aria_label_value !== (button_aria_label_value = /*label*/\n        ctx[3] ? /*label*/\n        ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n        if (dirty & /*classes, secondary*/\n        18 && button_class_value !== (button_class_value = \"\".concat( /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat( /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''))) {\n          attr(button, \"class\", button_class_value);\n        }\n        if (dirty & /*disabled*/\n        4) {\n          button.disabled = /*disabled*/\n          ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n      step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n    function getConfigOption(option) {\n      if (isFunction(option)) {\n        return option = option.call(step);\n      }\n      return option;\n    }\n    $$self.$$set = function ($$props) {\n      if ('config' in $$props) $$invalidate(6, config = $$props.config);\n      if ('step' in $$props) $$invalidate(7, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*config, step*/\n      192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);\n          $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text ? getConfigOption(config.text) : null);\n        }\n      }\n    };\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n    var _super = _createSuper(Shepherd_button);\n    function Shepherd_button(options) {\n      var _this3;\n      _classCallCheck(this, Shepherd_button);\n      _this3 = _super.call(this);\n      init(_assertThisInitialized(_this3), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this3;\n    }\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.49.0 */\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  } // (24:4) {#if buttons}\n\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value = /*buttons*/\n    ctx[1];\n    var each_blocks = [];\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n    return {\n      c: function c() {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          each_blocks[_i3].m(target, anchor);\n        }\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty & /*buttons, step*/\n        3) {\n          each_value = /*buttons*/\n          ctx[1];\n          var _i4;\n          for (_i4 = 0; _i4 < each_value.length; _i4 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i4);\n            if (each_blocks[_i4]) {\n              each_blocks[_i4].p(child_ctx, dirty);\n              transition_in(each_blocks[_i4], 1);\n            } else {\n              each_blocks[_i4] = create_each_block(child_ctx);\n              each_blocks[_i4].c();\n              transition_in(each_blocks[_i4], 1);\n              each_blocks[_i4].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (_i4 = each_value.length; _i4 < each_blocks.length; _i4 += 1) {\n            out(_i4);\n          }\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n          transition_in(each_blocks[_i5]);\n        }\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n          transition_out(each_blocks[_i6]);\n        }\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  } // (25:8) {#each buttons as config}\n\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config: /*config*/\n        ctx[2],\n        step: /*step*/\n        ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty & /*buttons*/\n        2) shepherdbutton_changes.config = /*config*/\n        ctx[2];\n        if (dirty & /*step*/\n        1) shepherdbutton_changes.step = /*step*/\n        ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block = /*buttons*/\n    ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref8 = _slicedToArray(_ref, 1),\n          dirty = _ref8[0];\n        if ( /*buttons*/\n        ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n            if (dirty & /*buttons*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('step' in $$props) $$invalidate(0, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n    return [step, buttons];\n  }\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n    var _super2 = _createSuper(Shepherd_footer);\n    function Shepherd_footer(options) {\n      var _this4;\n      _classCallCheck(this, Shepherd_footer);\n      _this4 = _super2.call(this);\n      init(_assertThisInitialized(_this4), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this4;\n    }\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.49.0 */\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value = /*cancelIcon*/\n        ctx[0].label ? /*cancelIcon*/\n        ctx[0].label : 'Close Tour');\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n        if (!mounted) {\n          dispose = listen(button, \"click\", /*handleCancelClick*/\n          ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref9 = _slicedToArray(_ref, 1),\n          dirty = _ref9[0];\n        if (dirty & /*cancelIcon*/\n        1 && button_aria_label_value !== (button_aria_label_value = /*cancelIcon*/\n        ctx[0].label ? /*cancelIcon*/\n        ctx[0].label : 'Close Tour')) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n      step = $$props.step;\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n    $$self.$$set = function ($$props) {\n      if ('cancelIcon' in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [cancelIcon, handleCancelClick, step];\n  }\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n    function Shepherd_cancel_icon(options) {\n      var _this5;\n      _classCallCheck(this, Shepherd_cancel_icon);\n      _this5 = _super3.call(this);\n      init(_assertThisInitialized(_this5), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this5;\n    }\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.49.0 */\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\", /*labelId*/\n        ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref) {\n        var _ref10 = _slicedToArray(_ref, 1),\n          dirty = _ref10[0];\n        if (dirty & /*labelId*/\n        2) {\n          attr(h3, \"id\", /*labelId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      element = $$props.element,\n      title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('title' in $$props) $$invalidate(2, title = $$props.title);\n    };\n    return [element, labelId, title, h3_binding];\n  }\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n    var _super4 = _createSuper(Shepherd_title);\n    function Shepherd_title(options) {\n      var _this6;\n      _classCallCheck(this, Shepherd_title);\n      _this6 = _super4.call(this);\n      init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this6;\n    }\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.49.0 */\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId: /*labelId*/\n        ctx[0],\n        title: /*title*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty & /*labelId*/\n        1) shepherdtitle_changes.labelId = /*labelId*/\n        ctx[0];\n        if (dirty & /*title*/\n        4) shepherdtitle_changes.title = /*title*/\n        ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  } // (39:4) {#if cancelIcon && cancelIcon.enabled}\n\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon: /*cancelIcon*/\n        ctx[3],\n        step: /*step*/\n        ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty & /*cancelIcon*/\n        8) shepherdcancelicon_changes.cancelIcon = /*cancelIcon*/\n        ctx[3];\n        if (dirty & /*step*/\n        2) shepherdcancelicon_changes.step = /*step*/\n        ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 = /*title*/\n    ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 = /*cancelIcon*/\n    ctx[3] && /*cancelIcon*/\n    ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref11 = _slicedToArray(_ref, 1),\n          dirty = _ref11[0];\n        if ( /*title*/\n        ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*title*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if ( /*cancelIcon*/\n        ctx[3] && /*cancelIcon*/\n        ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*cancelIcon*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      step = $$props.step;\n    var title, cancelIcon;\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(1, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n    return [labelId, step, title, cancelIcon];\n  }\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n    var _super5 = _createSuper(Shepherd_header);\n    function Shepherd_header(options) {\n      var _this7;\n      _classCallCheck(this, Shepherd_header);\n      _this7 = _super5.call(this);\n      init(_assertThisInitialized(_this7), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this7;\n    }\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.49.0 */\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\", /*descriptionId*/\n        ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref) {\n        var _ref12 = _slicedToArray(_ref, 1),\n          dirty = _ref12[0];\n        if (dirty & /*descriptionId*/\n        2) {\n          attr(div, \"id\", /*descriptionId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      element = $$props.element,\n      step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [element, descriptionId, step, div_binding];\n  }\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n    var _super6 = _createSuper(Shepherd_text);\n    function Shepherd_text(options) {\n      var _this8;\n      _classCallCheck(this, Shepherd_text);\n      _this8 = _super6.call(this);\n      init(_assertThisInitialized(_this8), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this8;\n    }\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.49.0 */\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId: /*labelId*/\n        ctx[1],\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty & /*labelId*/\n        2) shepherdheader_changes.labelId = /*labelId*/\n        ctx[1];\n        if (dirty & /*step*/\n        4) shepherdheader_changes.step = /*step*/\n        ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  } // (28:2) {#if !isUndefined(step.options.text)}\n\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId: /*descriptionId*/\n        ctx[0],\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty & /*descriptionId*/\n        1) shepherdtext_changes.descriptionId = /*descriptionId*/\n        ctx[0];\n        if (dirty & /*step*/\n        4) shepherdtext_changes.step = /*step*/\n        ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  } // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty & /*step*/\n        4) shepherdfooter_changes.step = /*step*/\n        ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined( /*step*/\n    ctx[2].options.title) || /*step*/\n    ctx[2].options.cancelIcon && /*step*/\n    ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined( /*step*/\n    ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray( /*step*/\n    ctx[2].options.buttons) && /*step*/\n    ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref13 = _slicedToArray(_ref, 1),\n          dirty = _ref13[0];\n        if (dirty & /*step*/\n        4) show_if_2 = !isUndefined( /*step*/\n        ctx[2].options.title) || /*step*/\n        ctx[2].options.cancelIcon && /*step*/\n        ctx[2].options.cancelIcon.enabled;\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/\n        4) show_if_1 = !isUndefined( /*step*/\n        ctx[2].options.text);\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/\n        4) show_if = Array.isArray( /*step*/\n        ctx[2].options.buttons) && /*step*/\n        ctx[2].options.buttons.length;\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      labelId = $$props.labelId,\n      step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [descriptionId, labelId, step];\n  }\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n    var _super7 = _createSuper(Shepherd_content);\n    function Shepherd_content(options) {\n      var _this9;\n      _classCallCheck(this, Shepherd_content);\n      _this9 = _super7.call(this);\n      init(_assertThisInitialized(_this9), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this9;\n    }\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.49.0 */\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block = /*step*/\n    ctx[4].options.arrow && /*step*/\n    ctx[4].options.attachTo && /*step*/\n    ctx[4].options.attachTo.element && /*step*/\n    ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId: /*descriptionId*/\n        ctx[2],\n        labelId: /*labelId*/\n        ctx[3],\n        step: /*step*/\n        ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined( /*step*/\n      ctx[4].options.text) ? /*descriptionId*/\n      ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value = /*step*/\n      ctx[4].options.title ? /*labelId*/\n      ctx[3] : null\n    }, /*dataStepId*/\n    ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n\n        ctx[13](div);\n        current = true;\n        if (!mounted) {\n          dispose = listen(div, \"keydown\", /*handleKeyDown*/\n          ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref14 = _slicedToArray(_ref, 1),\n          dirty = _ref14[0];\n        if ( /*step*/\n        ctx[4].options.arrow && /*step*/\n        ctx[4].options.attachTo && /*step*/\n        ctx[4].options.attachTo.element && /*step*/\n        ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        var shepherdcontent_changes = {};\n        if (dirty & /*descriptionId*/\n        4) shepherdcontent_changes.descriptionId = /*descriptionId*/\n        ctx[2];\n        if (dirty & /*labelId*/\n        8) shepherdcontent_changes.labelId = /*labelId*/\n        ctx[3];\n        if (dirty & /*step*/\n        16) shepherdcontent_changes.step = /*step*/\n        ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty & /*step, descriptionId*/\n        20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined( /*step*/\n        ctx[4].options.text) ? /*descriptionId*/\n        ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty & /*step, labelId*/\n        24 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*step*/\n        ctx[4].options.title ? /*labelId*/\n        ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty & /*dataStepId*/\n        2 && /*dataStepId*/\n        ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n  function getClassesArray(classes) {\n    return classes.split(' ').filter(function (className) {\n      return !!className.length;\n    });\n  }\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n      element = $$props.element,\n      descriptionId = $$props.descriptionId,\n      firstFocusableElement = $$props.firstFocusableElement,\n      focusableElements = $$props.focusableElements,\n      labelId = $$props.labelId,\n      lastFocusableElement = $$props.lastFocusableElement,\n      step = $$props.step,\n      dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n    var getElement = function getElement() {\n      return element;\n    };\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n        if (oldClasses.length) {\n          var _element$classList;\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n        if (newClasses.length) {\n          var _element$classList2;\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n        tour = _step.tour;\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          } // Backward tab\n\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n          break;\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n          break;\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n          break;\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n          break;\n      }\n    };\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('classPrefix' in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('descriptionId' in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if ('firstFocusableElement' in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if ('focusableElements' in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if ('labelId' in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if ('lastFocusableElement' in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if ('step' in $$props) $$invalidate(4, step = $$props.step);\n      if ('dataStepId' in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n    var _super8 = _createSuper(Shepherd_element);\n    function Shepherd_element(options) {\n      var _this10;\n      _classCallCheck(this, Shepherd_element);\n      _this10 = _super8.call(this);\n      init(_assertThisInitialized(_this10), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this10;\n    }\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n    return Shepherd_element;\n  }(SvelteComponent);\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n          if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset,\n            // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n            original.elementScroll.call(this,\n            // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft,\n            // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n    var _super9 = _createSuper(Step);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you dont specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n     * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n     * @param {string} options.attachTo.on The optional direction to place the Popper tooltip relative to the element.\n     *   - Possible string values: 'auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesnt have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel  be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.popperOptions Extra options to pass to Popper\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour, options) {\n      var _this11;\n      _classCallCheck(this, Step);\n      if (options === void 0) {\n        options = {};\n      }\n      _this11 = _super9.call(this, tour, options);\n      _this11.tour = tour;\n      _this11.classPrefix = _this11.tour.options ? normalizePrefix(_this11.tour.options.classPrefix) : '';\n      _this11.styles = tour.styles;\n      /**\n       * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n       * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n       * @type {null|{}|{element, to}}\n       * @private\n       */\n\n      _this11._resolvedAttachTo = null;\n      autoBind(_assertThisInitialized(_this11));\n      _this11._setOptions(options);\n      return _possibleConstructorReturn(_this11, _assertThisInitialized(_this11));\n    }\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n      /**\n       * Remove the step, delete the step's element, and destroy the Popper instance for the step.\n       * Triggers `destroy` event\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.tooltip) {\n          this.tooltip.destroy();\n          this.tooltip = null;\n        }\n        if (isHTMLElement$1(this.el) && this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n          this.el = null;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('destroy');\n      }\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n      /**\n       * Hide the step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n        if (this.el) {\n          this.el.hidden = true;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('hide');\n      }\n      /**\n       * Resolves attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_resolveAttachToOptions\",\n      value: function _resolveAttachToOptions() {\n        this._resolvedAttachTo = parseAttachTo(this);\n        return this._resolvedAttachTo;\n      }\n      /**\n       * A selector for resolved attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_getResolvedAttachToOptions\",\n      value: function _getResolvedAttachToOptions() {\n        if (this._resolvedAttachTo === null) {\n          return this._resolveAttachToOptions();\n        }\n        return this._resolvedAttachTo;\n      }\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this12 = this;\n        if (isFunction(this.options.beforeShowPromise)) {\n          var beforeShowPromise = this.options.beforeShowPromise();\n          if (!isUndefined(beforeShowPromise)) {\n            return beforeShowPromise.then(function () {\n              return _this12._show();\n            });\n          }\n        }\n        this._show();\n      }\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _this$_getResolvedAtt = this._getResolvedAttachToOptions(),\n          element = _this$_getResolvedAtt.element;\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions(options) {\n        var _this13 = this;\n        if (options === void 0) {\n          options = {};\n        }\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options);\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this13.on(event, when[event], _this13);\n          });\n        }\n      }\n      /**\n       * Create the element and set up the Popper instance\n       * @private\n       */\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n        this.el = this._createTooltipContent();\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n        setupTooltip(this);\n      }\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a Popper instance for the tooltip, then triggers `show`.\n       * @private\n       */\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this14 = this;\n        this.trigger('before-show'); // Force resolve to make sure the options are updated on subsequent shows.\n\n        this._resolveAttachToOptions();\n        this._setupElements();\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n        this.tour.modal.setupForStep(this);\n        this._styleTargetElementForStep(this);\n        this.el.hidden = false; // start scrolling to target before showing the step\n\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this14._scrollTo(_this14.options.scrollTo);\n          });\n        }\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n        if (!targetElement) {\n          return;\n        }\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n        targetElement.classList.remove('shepherd-target-click-disabled');\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number} [r=0] - Corner Radius. Keep this smaller than  half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n  function makeOverlayPath(_ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      _ref$r = _ref.r,\n      r = _ref$r === void 0 ? 0 : _ref$r;\n    var _window = window,\n      w = _window.innerWidth,\n      h = _window.innerHeight;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + r, \",\").concat(y, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \",\").concat(r, \"V\").concat(height + y - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \",\").concat(r, \"H\").concat(width + x - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \"-\").concat(r, \"V\").concat(y + r, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \"-\").concat(r, \"Z\");\n  }\n\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.49.0 */\n\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\", /*pathDefinition*/\n        ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat( /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n\n        ctx[11](svg);\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\", /*_preventModalOverlayTouch*/\n          ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref15 = _slicedToArray(_ref, 1),\n          dirty = _ref15[0];\n        if (dirty & /*pathDefinition*/\n        4) {\n          attr(path, \"d\", /*pathDefinition*/\n          ctx[2]);\n        }\n        if (dirty & /*modalIsVisible*/\n        2 && svg_class_value !== (svg_class_value = \"\".concat( /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n    return _getScrollParent(element.parentElement);\n  }\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return {\n      y: top,\n      height: height\n    };\n  }\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n      openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n    var getElement = function getElement() {\n      return element;\n    };\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n    function hide() {\n      $$invalidate(1, modalIsVisible = false); // Ensure we cleanup all event listeners when we hide the modal\n\n      _cleanupStepEventListeners();\n    }\n    function positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, targetElement) {\n      if (modalOverlayOpeningPadding === void 0) {\n        modalOverlayOpeningPadding = 0;\n      }\n      if (modalOverlayOpeningRadius === void 0) {\n        modalOverlayOpeningRadius = 0;\n      }\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n          y = _getVisibleHeight2.y,\n          height = _getVisibleHeight2.height;\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          x = _targetElement$getBou.x,\n          width = _targetElement$getBou.width,\n          _left = _targetElement$getBou.left; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || _left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n        show();\n      } else {\n        hide();\n      }\n    }\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n      window.removeEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n\n    function _styleForStep(step) {\n      var _step$options = step.options,\n        modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n      var scrollParent = _getScrollParent(step.target); // Setup recursive function to call requestAnimationFrame to update the modal opening position\n\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n      rafLoop();\n      _addStepEventListeners();\n    }\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*openingProperties*/\n      16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n    var _super10 = _createSuper(Shepherd_modal);\n    function Shepherd_modal(options) {\n      var _this15;\n      _classCallCheck(this, Shepherd_modal);\n      _this15 = _super10.call(this);\n      init(_assertThisInitialized(_this15), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this15;\n    }\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n    return Shepherd_modal;\n  }(SvelteComponent);\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n    var _super11 = _createSuper(Tour);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean} options.confirmCancel If true, will issue a `window.confirm` before cancelling\n     * @param {string} options.confirmCancelMessage The message to display in the confirm dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour(options) {\n      var _this16;\n      _classCallCheck(this, Tour);\n      if (options === void 0) {\n        options = {};\n      }\n      _this16 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this16));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this16.options = Object.assign({}, defaultTourOptions, options);\n      _this16.classPrefix = normalizePrefix(_this16.options.classPrefix);\n      _this16.steps = [];\n      _this16.addSteps(_this16.options.steps); // Pass these events onto the global Shepherd object\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this16.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this16);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n      _this16._setTourID();\n      return _possibleConstructorReturn(_this16, _assertThisInitialized(_this16));\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n        return step;\n      }\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this17 = this;\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this17.addStep(step);\n          });\n        }\n        return this;\n      }\n      /**\n       * Go to the previous step in the tour\n       */\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       */\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        if (this.options.confirmCancel) {\n          var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n          var stopTour = window.confirm(cancelMessage);\n          if (stopTour) {\n            this._done('cancel');\n          }\n        } else {\n          this._done('cancel');\n        }\n      }\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n      /**\n       * Hide the current step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this18 = this;\n        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n            step.destroy();\n            _this18.steps.splice(i, 1);\n            return true;\n          }\n        });\n        if (current && current.id === name) {\n          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n    }, {\n      key: \"show\",\n      value: function show(key, forward) {\n        if (key === void 0) {\n          key = 0;\n        }\n        if (forward === void 0) {\n          forward = true;\n        }\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n        if (step) {\n          this._updateStateBeforeShow();\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n      /**\n       * Start the tour\n       */\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start'); // Save the focused element before the tour opens\n\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n        this._setupModal();\n        this._setupActiveTour();\n        this.next();\n      }\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n        if (this.modal) {\n          this.modal.hide();\n        }\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        } // Focus the element that was focused before the tour started\n\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n      /**\n       * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          var nextIndex = forward ? index + 1 : index - 1;\n          this.show(nextIndex, forward);\n        }\n      }\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n    return Tour;\n  }(Evented);\n  Object.assign(Shepherd, {\n    Tour: Tour,\n    Step: Step\n  });\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUVBLElBQUlBLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFUQSxDQUEyQkMsS0FBM0IsRUFBa0M7SUFDekQsT0FBT0MsZUFBZSxDQUFDRCxLQUFELENBQWYsSUFDSCxDQUFDRSxTQUFTLENBQUNGLEtBQUQsQ0FEZDtFQUVBLENBSEQ7RUFLQSxTQUFTQyxlQUFUQSxDQUF5QkQsS0FBekIsRUFBZ0M7SUFDL0IsT0FBTyxDQUFDLENBQUNBLEtBQUYsSUFBV0csT0FBQSxDQUFPSCxLQUFQLE1BQWlCLFFBQW5DO0VBQ0E7RUFFRCxTQUFTRSxTQUFUQSxDQUFtQkYsS0FBbkIsRUFBMEI7SUFDekIsSUFBSUksV0FBVyxHQUFHQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCQyxJQUExQixDQUErQlIsS0FBL0IsQ0FBbEI7SUFFQSxPQUFPSSxXQUFXLEtBQUssaUJBQWhCLElBQ0hBLFdBQVcsS0FBSyxlQURiLElBRUhLLGNBQWMsQ0FBQ1QsS0FBRCxDQUZsQjtFQUdBOztFQUdELElBQUlVLFlBQVksR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxNQUFNLENBQUNDLEdBQTFEO0VBQ0EsSUFBSUMsa0JBQWtCLEdBQUdILFlBQVksR0FBR0MsTUFBTSxDQUFDQyxHQUFQLENBQVcsZUFBWCxDQUFILEdBQWlDLE1BQXRFO0VBRUEsU0FBU0gsY0FBVEEsQ0FBd0JULEtBQXhCLEVBQStCO0lBQzlCLE9BQU9BLEtBQUssQ0FBQ2MsUUFBTixLQUFtQkQsa0JBQTFCO0VBQ0E7RUFFRCxTQUFTRSxXQUFUQSxDQUFxQkMsR0FBckIsRUFBMEI7SUFDekIsT0FBT0MsS0FBSyxDQUFDQyxPQUFOLENBQWNGLEdBQWQsQ0FBcUIsS0FBckIsR0FBMEIsRUFBakM7RUFDQTtFQUVELFNBQVNHLDZC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TUFBUCxDQUFjbXZCLFFBQWQsRUFBd0I7SUFBRUMsSUFBRixFQUFFQSxJQUFGO0lBQVF4RjtFQUFSLENBQXhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcz81YWQxIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy91dGlscy90eXBlLWNoZWNrLmpzPzFmZDMiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2V2ZW50ZWQuanM/OTczZCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvdXRpbHMvYXV0by1iaW5kLmpzPzdiMTYiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL2JpbmQuanM/YTUxNSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzPzQ2OTciLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/OTA2MCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanM/OWE5NCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzPzdjZjgiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/MTJlYiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanM/MTU3ZCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanM/M2I4YyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanM/ZGQxNCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzPzc4MDMiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvY29udGFpbnMuanM/NTgxMCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzPzA5MDgiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanM/MzdkNCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanM/Mzg0OCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzP2UwODkiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzPzU4MmEiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanM/NWQwYiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcz9kMDkzIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzP2QwN2YiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanM/ODBmNSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcz81NDExIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzP2QxMzAiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanM/YzAxZiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzPzYzOTEiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanM/NzkzNSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzP2EwMDYiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcz9mODFlIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcz84YTcwIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanM/NjZkMyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanM/ZDdmZSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanM/MzMxZSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcz83ODYzIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz9hMzJhIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzPzZmNTkiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzPzljMzkiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzP2QxNmQiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcz80ZTc1Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanM/YjUzNCIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzPzJlYTEiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcz9kYjQ4Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanM/YWI5NyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanM/YzM2OSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzPzU4MDEiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzP2Q4YzciLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzP2Y5OGUiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanM/YjdlNiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzPzY2Y2YiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9kZDJhIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanM/Y2ZhYiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzP2I4MGIiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcz9iMDY5Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzP2E5MDAiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanM/NTE1ZSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvdXRpbHMvcG9wcGVyLW9wdGlvbnMuanM/YzY5YiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvdXRpbHMvZ2VuZXJhbC5qcz9iNDJkIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvaW50ZXJuYWwvaW5kZXgubWpzPzA0ZjciLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtYnV0dG9uLnN2ZWx0ZT83OGM1Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWZvb3Rlci5zdmVsdGU/YWY0NyIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1jYW5jZWwtaWNvbi5zdmVsdGU/NzljMSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10aXRsZS5zdmVsdGU/Y2FjMiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1oZWFkZXIuc3ZlbHRlPzJmMjciLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtdGV4dC5zdmVsdGU/YWNlZiIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1jb250ZW50LnN2ZWx0ZT9mMDdlIiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWVsZW1lbnQuc3ZlbHRlP2I1ODYiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb290aHNjcm9sbC1wb2x5ZmlsbC9kaXN0L3Ntb290aHNjcm9sbC5qcz9lNmM4Iiwid2VicGFjazovL1Z1ZXh5Ly4uLy4uL3NyYy9qcy9zdGVwLmpzP2FkOGQiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3V0aWxzL2NsZWFudXAuanM/NmRjYSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvdXRpbHMvb3ZlcmxheS1wYXRoLmpzP2NkNTMiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtbW9kYWwuc3ZlbHRlP2Y1NGIiLCJ3ZWJwYWNrOi8vVnVleHkvLi4vLi4vc3JjL2pzL3RvdXIuanM/Mzk1MSIsIndlYnBhY2s6Ly9WdWV4eS8uLi8uLi9zcmMvanMvc2hlcGhlcmQuanM/NTE0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG5cdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2Vcblx0fVxuXHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZVxufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuXHRcdD8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiB0YXJnZXQucHJvcGVydHlJc0VudW1lcmFibGUoc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEVsZW1lbnRgLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYW4gRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgSFRNTEVsZW1lbnRgLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYW4gSFRNTEVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrJztcblxuZXhwb3J0IGNsYXNzIEV2ZW50ZWQge1xuICBvbihldmVudCwgaGFuZGxlciwgY3R4LCBvbmNlID0gZmFsc2UpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3NbZXZlbnRdKSkge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5iaW5kaW5nc1tldmVudF0ucHVzaCh7IGhhbmRsZXIsIGN0eCwgb25jZSB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25jZShldmVudCwgaGFuZGxlciwgY3R4KSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGhhbmRsZXIsIGN0eCwgdHJ1ZSk7XG4gIH1cblxuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykgfHwgaXNVbmRlZmluZWQodGhpcy5iaW5kaW5nc1tldmVudF0pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2V2ZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uZm9yRWFjaCgoYmluZGluZywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcuaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJpZ2dlcihldmVudCwgLi4uYXJncykge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykgJiYgdGhpcy5iaW5kaW5nc1tldmVudF0pIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLmZvckVhY2goKGJpbmRpbmcsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBoYW5kbGVyLCBvbmNlIH0gPSBiaW5kaW5nO1xuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjdHggfHwgdGhpcztcblxuICAgICAgICBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXG4gICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsIi8qKlxuICogQmluZHMgYWxsIHRoZSBtZXRob2RzIG9uIGEgSlMgQ2xhc3MgdG8gdGhlIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBjbGFzcy5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2F1dG8tYmluZFxuICogQHBhcmFtIHtvYmplY3R9IHNlbGYgVGhlIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBjbGFzc1xuICogQHJldHVybiB7b2JqZWN0fSBUaGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF1dG9CaW5kKHNlbGYpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNlbGYuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWwgPSBzZWxmW2tleV07XG4gICAgaWYgKGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmW2tleV0gPSB2YWwuYmluZChzZWxmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi90eXBlLWNoZWNrJztcblxuLyoqXG4gKiBTZXRzIHVwIHRoZSBoYW5kbGVyIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgYWR2YW5jZSB0aGUgdG91clxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3NldHVwQWR2YW5jZU9uSGFuZGxlcihzZWxlY3Rvciwgc3RlcCkge1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKHN0ZXAuaXNPcGVuKCkpIHtcbiAgICAgIGNvbnN0IHRhcmdldElzRWwgPSBzdGVwLmVsICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IHN0ZXAuZWw7XG4gICAgICBjb25zdCB0YXJnZXRJc1NlbGVjdG9yID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKHNlbGVjdG9yKSAmJiBldmVudC5jdXJyZW50VGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAodGFyZ2V0SXNTZWxlY3RvciB8fCB0YXJnZXRJc0VsKSB7XG4gICAgICAgIHN0ZXAudG91ci5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEJpbmQgdGhlIGV2ZW50IGhhbmRsZXIgZm9yIGFkdmFuY2VPblxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kQWR2YW5jZShzdGVwKSB7XG4gIC8vIEFuIGVtcHR5IHNlbGVjdG9yIG1hdGNoZXMgdGhlIHN0ZXAgZWxlbWVudFxuICBjb25zdCB7IGV2ZW50LCBzZWxlY3RvciB9ID0gc3RlcC5vcHRpb25zLmFkdmFuY2VPbiB8fCB7fTtcbiAgaWYgKGV2ZW50KSB7XG4gICAgY29uc3QgaGFuZGxlciA9IF9zZXR1cEFkdmFuY2VPbkhhbmRsZXIoc2VsZWN0b3IsIHN0ZXApO1xuXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYWxzbyBiaW5kL3VuYmluZCBvbiBzaG93L2hpZGVcbiAgICBsZXQgZWw7XG4gICAgdHJ5IHtcbiAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVE9ET1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKHNlbGVjdG9yKSAmJiAhZWwpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgICBgTm8gZWxlbWVudCB3YXMgZm91bmQgZm9yIHRoZSBzZWxlY3RvciBzdXBwbGllZCB0byBhZHZhbmNlT246ICR7c2VsZWN0b3J9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgIHN0ZXAub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHRydWUpO1xuICAgICAgc3RlcC5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAnYWR2YW5jZU9uIHdhcyBkZWZpbmVkLCBidXQgbm8gZXZlbnQgbmFtZSB3YXMgcGFzc2VkLidcbiAgICApO1xuICB9XG59XG4iLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwiaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcblxuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSAmJiBpbmNsdWRlU2NhbGUpIHtcbiAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIG9mZnNldFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDsgLy8gRG8gbm90IGF0dGVtcHQgdG8gZGl2aWRlIGJ5IDAsIG90aGVyd2lzZSB3ZSBnZXQgYEluZmluaXR5YCBhcyBzY2FsZVxuICAgIC8vIEZhbGxiYWNrIHRvIDEgaW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgYDBgXG5cbiAgICBpZiAob2Zmc2V0V2lkdGggPiAwKSB7XG4gICAgICBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIG9mZnNldFdpZHRoIHx8IDE7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldEhlaWdodCA+IDApIHtcbiAgICAgIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIG9mZnNldEhlaWdodCB8fCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggLyBzY2FsZVgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHNjYWxlWSxcbiAgICB0b3A6IHJlY3QudG9wIC8gc2NhbGVZLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC8gc2NhbGVYLFxuICAgIGJvdHRvbTogcmVjdC5ib3R0b20gLyBzY2FsZVksXG4gICAgbGVmdDogcmVjdC5sZWZ0IC8gc2NhbGVYLFxuICAgIHg6IHJlY3QubGVmdCAvIHNjYWxlWCxcbiAgICB5OiByZWN0LnRvcCAvIHNjYWxlWVxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gXCIuL2lzVGFibGVFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuICB2YXIgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpICE9PSAtMTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iLCJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJywgJ3RoZSBhcnJvdy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCAnZWxlbWVudC4nXS5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjQueDtcbiAgeSA9IF9yZWY0Lnk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjUpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjUuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjUub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciB0cmFuc2l0aW9uUHJvcGVydHkgPSBnZXRDb21wdXRlZFN0eWxlKHN0YXRlLmVsZW1lbnRzLnBvcHBlcikudHJhbnNpdGlvblByb3BlcnR5IHx8ICcnO1xuXG4gICAgaWYgKGFkYXB0aXZlICYmIFsndHJhbnNmb3JtJywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLnNvbWUoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvblByb3BlcnR5LmluZGV4T2YocHJvcGVydHkpID49IDA7XG4gICAgfSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogRGV0ZWN0ZWQgQ1NTIHRyYW5zaXRpb25zIG9uIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nJywgJ0NTUyBwcm9wZXJ0aWVzOiBcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLicsICdcXG5cXG4nLCAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JywgJ2ZvciBzbW9vdGggdHJhbnNpdGlvbnMsIG9yIHJlbW92ZSB0aGVzZSBwcm9wZXJ0aWVzIGZyb20gdGhlIENTUycsICd0cmFuc2l0aW9uIGRlY2xhcmF0aW9uIG9uIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBvbmx5IHRyYW5zaXRpb25pbmcnLCAnb3BhY2l0eSBvciBiYWNrZ3JvdW5kLWNvbG9yIGZvciBleGFtcGxlLicsICdcXG5cXG4nLCAnV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBwb3BwZXIgZWxlbWVudCBhcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGlubmVyJywgJ2VsZW1lbnQgdGhhdCBjYW4gaGF2ZSBhbnkgQ1NTIHByb3BlcnR5IHRyYW5zaXRpb25lZCBmb3IgYW5pbWF0aW9ucy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXG4gICAgaXNGaXhlZDogc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59OyIsInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXG4gIC8vIGNhbiBiZSBvYnNjdXJlZCB1bmRlcm5lYXRoIGl0LlxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxuICAvLyB0byBvdmVyZmxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gdG9vIGVhcmx5LlxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xuICAgIC8vIGVycm9ycyBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgc28gd2UgbmVlZCB0byBjaGVjayBwcmVjaXNpb24uXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cbiAgICAvLyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZpc3VhbFZpZXdwb3J0LnNjYWxlIC0gdmlzdWFsVmlld3BvcnQud2lkdGgpIDxcbiAgICAvLyAwLjAwMVxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFwiTm90IFNhZmFyaVwiIHVzZXJBZ2VudFxuXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQsIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0iLCJpbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLCAncGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uJywgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJywgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgdmFsaWRhdGVNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanNcIjtcbmltcG9ydCB1bmlxdWVCeSBmcm9tIFwiLi91dGlscy91bmlxdWVCeS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IG1lcmdlQnlOYW1lIGZyb20gXCIuL3V0aWxzL21lcmdlQnlOYW1lLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4vZW51bXMuanNcIjtcbnZhciBJTlZBTElEX0VMRU1FTlRfRVJST1IgPSAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtb2RpZmllcnMgaXMgaW52YWxpZCBmb3IgYW55IHJlYXNvblxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgbW9kaWZpZXJzID0gdW5pcXVlQnkoW10uY29uY2F0KG9yZGVyZWRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKTtcblxuICAgICAgICAgIGlmIChnZXRCYXNlUGxhY2VtZW50KHN0YXRlLm9wdGlvbnMucGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgICAgICAgICAgdmFyIGZsaXBNb2RpZmllciA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2ZsaXAnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZmxpcE1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCAncHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwb3BwZXIpLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkxlZnQ7IC8vIFdlIG5vIGxvbmdlciB0YWtlIGludG8gYWNjb3VudCBgbWFyZ2luc2Agb24gdGhlIHBvcHBlciwgYW5kIGl0IGNhblxuICAgICAgICAgIC8vIGNhdXNlIGJ1Z3Mgd2l0aCBwb3NpdGlvbmluZywgc28gd2UnbGwgd2FybiB0aGUgY29uc3VtZXJcblxuXG4gICAgICAgICAgaWYgKFttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnRdLnNvbWUoZnVuY3Rpb24gKG1hcmdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWFyZ2luKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsICdiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS4nLCAnVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhcycsICd0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYCcsICdtb2RpZmllcnMuJ10uam9pbignICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfX2RlYnVnX2xvb3BzX18gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIF9fZGVidWdfbG9vcHNfXyArPSAxO1xuXG4gICAgICAgICAgICBpZiAoX19kZWJ1Z19sb29wc19fID4gMTAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5GSU5JVEVfTE9PUF9FUlJPUik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXMsIG9mZnNldCwgZmxpcCwgcHJldmVudE92ZXJmbG93LCBhcnJvdywgaGlkZV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsiLCJmdW5jdGlvbiBfZ2V0Q2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gICAgICBmbih7IHN0YXRlIH0pIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICBpZiAobmFtZSAhPT0gJ3BvcHBlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSdcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBhZGFwdGl2ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbW9kaWZpZXIgZm9yIHBvcHBlciB0aGF0IHdpbGwgaGVscCBmb2N1cyB0aGUgZWxlbWVudCBhZnRlciBpdCBoYXNcbiAqIGJlZW4gcmVuZGVyZWRcbiAqXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZvY3VzIGFmdGVyIHJlbmRlciBtb2RpZmllciBjb25maWd1cmF0aW9uIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIoc3RlcCkge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmb2N1c0FmdGVyUmVuZGVyJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnYWZ0ZXJXcml0ZScsXG4gICAgZm4oKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0ZXAuZWwpIHtcbiAgICAgICAgICBjb25zdCBmb2N1c09wdGlvbnMgPSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHN0ZXAuZWwuZm9jdXMoZm9jdXNPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBhcnJheSBvZiBvcHRpb25zIGZvciBhIHRvb2x0aXAgdGhhdCBkb2Vzbid0IGhhdmUgYVxuICogdGFyZ2V0IGVsZW1lbnQgaW4gdGhlIERPTSAtLSBhbmQgdGh1cyBpcyBwb3NpdGlvbmVkIGluIHRoZSBjZW50ZXJcbiAqIG9mIHRoZSB2aWV3XG4gKlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmaW5hbCBQb3BwZXIgb3B0aW9ucyBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDZW50ZXJlZFBvcHBlcihzdGVwKSB7XG4gIGNvbnN0IGNlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllciA9IF9nZXRDZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIoKTtcblxuICBsZXQgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHN0cmF0ZWd5OiAnZml4ZWQnLFxuICAgIG1vZGlmaWVyczogW2dlbmVyYXRlRm9jdXNBZnRlclJlbmRlck1vZGlmaWVyKHN0ZXApXVxuICB9O1xuXG4gIHBvcHBlck9wdGlvbnMgPSB7XG4gICAgLi4ucG9wcGVyT3B0aW9ucyxcbiAgICBtb2RpZmllcnM6IEFycmF5LmZyb20oXG4gICAgICBuZXcgU2V0KFsuLi5wb3BwZXJPcHRpb25zLm1vZGlmaWVycywgLi4uY2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyXSlcbiAgICApXG4gIH07XG5cbiAgcmV0dXJuIHBvcHBlck9wdGlvbnM7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4vdHlwZS1jaGVjayc7XG5pbXBvcnQgeyBtYWtlQ2VudGVyZWRQb3BwZXIsIGdlbmVyYXRlRm9jdXNBZnRlclJlbmRlck1vZGlmaWVyIH0gZnJvbSAnLi9wb3BwZXItb3B0aW9ucyc7XG5cbi8qKlxuICogRW5zdXJlIGNsYXNzIHByZWZpeCBlbmRzIGluIGAtYFxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIHByZXBlbmQgdG8gdGhlIGNsYXNzIG5hbWVzIGdlbmVyYXRlZCBieSBuYW5vLWNzc1xuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcHJlZml4IGVuZGluZyBpbiBgLWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVByZWZpeChwcmVmaXgpIHtcbiAgaWYgKCFpc1N0cmluZyhwcmVmaXgpIHx8IHByZWZpeCA9PT0gJycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gcHJlZml4LmNoYXJBdChwcmVmaXgubGVuZ3RoIC0gMSkgIT09ICctJyA/IGAke3ByZWZpeH0tYCA6IHByZWZpeDtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhdHRhY2hUbyBvcHRpb25zLCBjb252ZXJ0aW5nIGVsZW1lbnQgb3B0aW9uIHZhbHVlIHRvIGEgcXVhbGlmaWVkIEhUTUxFbGVtZW50LlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7e318e2VsZW1lbnQsIG9ufX1cbiAqIGBlbGVtZW50YCBpcyBhIHF1YWxpZmllZCBIVE1MIEVsZW1lbnRcbiAqIGBvbmAgaXMgYSBzdHJpbmcgcG9zaXRpb24gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXR0YWNoVG8oc3RlcCkge1xuICBjb25zdCBvcHRpb25zID0gc3RlcC5vcHRpb25zLmF0dGFjaFRvIHx8IHt9O1xuICBjb25zdCByZXR1cm5PcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgaWYgKGlzRnVuY3Rpb24ocmV0dXJuT3B0cy5lbGVtZW50KSkge1xuICAgIC8vIEJpbmQgdGhlIGNhbGxiYWNrIHRvIHN0ZXAgc28gdGhhdCBpdCBoYXMgYWNjZXNzIHRvIHRoZSBvYmplY3QsIHRvIGVuYWJsZSBydW5uaW5nIGFkZGl0aW9uYWwgbG9naWNcbiAgICByZXR1cm5PcHRzLmVsZW1lbnQgPSByZXR1cm5PcHRzLmVsZW1lbnQuY2FsbChzdGVwKTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhyZXR1cm5PcHRzLmVsZW1lbnQpKSB7XG4gICAgLy8gQ2FuJ3Qgb3ZlcnJpZGUgdGhlIGVsZW1lbnQgaW4gdXNlciBvcHRzIHJlZmVyZW5jZSBiZWNhdXNlIHdlIGNhbid0XG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIGVsZW1lbnQgd2lsbCBleGlzdCBpbiB0aGUgZnV0dXJlLlxuICAgIHRyeSB7XG4gICAgICByZXR1cm5PcHRzLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJldHVybk9wdHMuZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVE9ET1xuICAgIH1cbiAgICBpZiAoIXJldHVybk9wdHMuZWxlbWVudCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFRoZSBlbGVtZW50IGZvciB0aGlzIFNoZXBoZXJkIHN0ZXAgd2FzIG5vdCBmb3VuZCAke29wdGlvbnMuZWxlbWVudH1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5PcHRzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc3RlcCBzaG91bGQgYmUgY2VudGVyZWQgb3Igbm90LiBEb2VzIG5vdCB0cmlnZ2VyIGF0dGFjaFRvLmVsZW1lbnQgZXZhbHVhdGlvbiwgbWFraW5nIGl0IGEgcHVyZVxuICogYWx0ZXJuYXRpdmUgZm9yIHRoZSBkZXByZWNhdGVkIHN0ZXAuaXNDZW50ZXJlZCgpIG1ldGhvZC5cbiAqIEBwYXJhbSByZXNvbHZlZEF0dGFjaFRvT3B0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRDZW50ZXJTdGVwKHJlc29sdmVkQXR0YWNoVG9PcHRpb25zKSB7XG4gIGlmIChyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHJlc29sdmVkQXR0YWNoVG9PcHRpb25zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBcbiAgcmV0dXJuICFyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucy5lbGVtZW50IHx8ICFyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucy5vbjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIG9wdGlvbnMgZm9yIHRoZSB0b29sdGlwIGFuZCBpbml0aWFsaXplc1xuICogYHN0ZXAudG9vbHRpcGAgYXMgYSBQb3BwZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwVG9vbHRpcChzdGVwKSB7XG4gIGlmIChzdGVwLnRvb2x0aXApIHtcbiAgICBzdGVwLnRvb2x0aXAuZGVzdHJveSgpO1xuICB9XG5cbiAgY29uc3QgYXR0YWNoVG9PcHRpb25zID0gc3RlcC5fZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKTtcblxuICBsZXQgdGFyZ2V0ID0gYXR0YWNoVG9PcHRpb25zLmVsZW1lbnQ7XG4gIGNvbnN0IHBvcHBlck9wdGlvbnMgPSBnZXRQb3BwZXJPcHRpb25zKGF0dGFjaFRvT3B0aW9ucywgc3RlcCk7XG5cbiAgaWYgKHNob3VsZENlbnRlclN0ZXAoYXR0YWNoVG9PcHRpb25zKSkge1xuICAgIHRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgY29udGVudCA9IHN0ZXAuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3NoZXBoZXJkLWNlbnRlcmVkJyk7XG4gIH1cblxuICBzdGVwLnRvb2x0aXAgPSBjcmVhdGVQb3BwZXIodGFyZ2V0LCBzdGVwLmVsLCBwb3BwZXJPcHRpb25zKTtcbiAgc3RlcC50YXJnZXQgPSBhdHRhY2hUb09wdGlvbnMuZWxlbWVudDtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSB1bmlxdWUgaWQgZm9yIHN0ZXBzLCB0b3VycywgbW9kYWxzLCBldGNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIGxldCBkID0gRGF0ZS5ub3coKTtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICBjb25zdCByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYFBvcHBlcmAgb3B0aW9ucyBmcm9tIGEgc2V0IG9mIGJhc2UgYGF0dGFjaFRvYCBvcHRpb25zXG4gKiBAcGFyYW0gYXR0YWNoVG9PcHRpb25zXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3BwZXJPcHRpb25zKGF0dGFjaFRvT3B0aW9ucywgc3RlcCkge1xuICBsZXQgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICBtb2RpZmllcnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhbHRBeGlzOiB0cnVlLFxuICAgICAgICAgIHRldGhlcjogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlRm9jdXNBZnRlclJlbmRlck1vZGlmaWVyKHN0ZXApXG4gICAgXSxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJ1xuICB9O1xuXG4gIGlmIChzaG91bGRDZW50ZXJTdGVwKGF0dGFjaFRvT3B0aW9ucykpIHtcbiAgICBwb3BwZXJPcHRpb25zID0gbWFrZUNlbnRlcmVkUG9wcGVyKHN0ZXApO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9wdGlvbnMucGxhY2VtZW50ID0gYXR0YWNoVG9PcHRpb25zLm9uO1xuICB9XG5cbiAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zID1cbiAgICBzdGVwLnRvdXIgJiYgc3RlcC50b3VyLm9wdGlvbnMgJiYgc3RlcC50b3VyLm9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zO1xuXG4gIGlmIChkZWZhdWx0U3RlcE9wdGlvbnMpIHtcbiAgICBwb3BwZXJPcHRpb25zID0gX21lcmdlTW9kaWZpZXJzKGRlZmF1bHRTdGVwT3B0aW9ucywgcG9wcGVyT3B0aW9ucyk7XG4gIH1cblxuICBwb3BwZXJPcHRpb25zID0gX21lcmdlTW9kaWZpZXJzKHN0ZXAub3B0aW9ucywgcG9wcGVyT3B0aW9ucyk7XG5cbiAgcmV0dXJuIHBvcHBlck9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIF9tZXJnZU1vZGlmaWVycyhzdGVwT3B0aW9ucywgcG9wcGVyT3B0aW9ucykge1xuICBpZiAoc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucykge1xuICAgIGxldCBtZXJnZWRQb3BwZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgcG9wcGVyT3B0aW9ucyxcbiAgICAgIHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgJiZcbiAgICAgIHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMubWFwKChtb2QpID0+IG1vZC5uYW1lKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkTW9kaWZpZXJzID0gcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMuZmlsdGVyKFxuICAgICAgICAobW9kKSA9PiAhbmFtZXMuaW5jbHVkZXMobW9kLm5hbWUpXG4gICAgICApO1xuXG4gICAgICBtZXJnZWRQb3BwZXJPcHRpb25zLm1vZGlmaWVycyA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBTZXQoWy4uLmZpbHRlcmVkTW9kaWZpZXJzLCAuLi5zdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVyc10pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZWRQb3BwZXJPcHRpb25zO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9wdGlvbnM7XG59XG4iLCJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3JjKVxuICAgICAgICB0YXJba10gPSBzcmNba107XG4gICAgcmV0dXJuIHRhcjtcbn1cbmZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGFkZF9sb2NhdGlvbihlbGVtZW50LCBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIpIHtcbiAgICBlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG4gICAgICAgIGxvYzogeyBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIgfVxuICAgIH07XG59XG5mdW5jdGlvbiBydW4oZm4pIHtcbiAgICByZXR1cm4gZm4oKTtcbn1cbmZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG4gICAgZm5zLmZvckVhY2gocnVuKTtcbn1cbmZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHNhZmVfbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5sZXQgc3JjX3VybF9lcXVhbF9hbmNob3I7XG5mdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcbiAgICBpZiAoIXNyY191cmxfZXF1YWxfYW5jaG9yKSB7XG4gICAgICAgIHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIH1cbiAgICBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmID0gdXJsO1xuICAgIHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cbmZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5mdW5jdGlvbiBpc19lbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zdG9yZShzdG9yZSwgbmFtZSkge1xuICAgIGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtuYW1lfScgaXMgbm90IGEgc3RvcmUgd2l0aCBhICdzdWJzY3JpYmUnIG1ldGhvZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgaWYgKHN0b3JlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHN1YnNjcmliZShzdG9yZSwgXyA9PiB2YWx1ZSA9IF8pKCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29tcG9uZW50X3N1YnNjcmliZShjb21wb25lbnQsIHN0b3JlLCBjYWxsYmFjaykge1xuICAgIGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25bMF0oc2xvdF9jdHgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuXG4gICAgICAgID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpXG4gICAgICAgIDogJCRzY29wZS5jdHg7XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG4gICAgICAgIGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG4gICAgICAgIGlmICgkJHNjb3BlLmRpcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQkc2NvcGUuZGlydHkgfCBsZXRzO1xuICAgIH1cbiAgICByZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGlmIChzbG90X2NoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG4gICAgICAgIHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3Qoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgY29uc3Qgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcbiAgICB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pO1xufVxuZnVuY3Rpb24gZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlKCQkc2NvcGUpIHtcbiAgICBpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgY29uc3QgZGlydHkgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gJCRzY29wZS5jdHgubGVuZ3RoIC8gMzI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRpcnR5W2ldID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBleGNsdWRlX2ludGVybmFsX3Byb3BzKHByb3BzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoa1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdWx0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfcmVzdF9wcm9wcyhwcm9wcywga2V5cykge1xuICAgIGNvbnN0IHJlc3QgPSB7fTtcbiAgICBrZXlzID0gbmV3IFNldChrZXlzKTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmICgha2V5cy5oYXMoaykgJiYga1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChyYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIGZuLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcbiAgICBzdG9yZS5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59XG5jb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG4gICAgcmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbmNvbnN0IGlzX2NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xubGV0IG5vdyA9IGlzX2NsaWVudFxuICAgID8gKCkgPT4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gICAgOiAoKSA9PiBEYXRlLm5vdygpO1xubGV0IHJhZiA9IGlzX2NsaWVudCA/IGNiID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYikgOiBub29wO1xuLy8gdXNlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBzZXRfbm93KGZuKSB7XG4gICAgbm93ID0gZm47XG59XG5mdW5jdGlvbiBzZXRfcmFmKGZuKSB7XG4gICAgcmFmID0gZm47XG59XG5cbmNvbnN0IHRhc2tzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcnVuX3Rhc2tzKG5vdykge1xuICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgIGlmICghdGFzay5jKG5vdykpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgICAgIHRhc2suZigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhc2tzLnNpemUgIT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xufVxuLyoqXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5IVxuICovXG5mdW5jdGlvbiBjbGVhcl9sb29wcygpIHtcbiAgICB0YXNrcy5jbGVhcigpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICovXG5mdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRhc2s7XG4gICAgaWYgKHRhc2tzLnNpemUgPT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IG5ldyBQcm9taXNlKGZ1bGZpbGwgPT4ge1xuICAgICAgICAgICAgdGFza3MuYWRkKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnQoKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUcmFjayB3aGljaCBub2RlcyBhcmUgY2xhaW1lZCBkdXJpbmcgaHlkcmF0aW9uLiBVbmNsYWltZWQgbm9kZXMgY2FuIHRoZW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbi8vIGF0IHRoZSBlbmQgb2YgaHlkcmF0aW9uIHdpdGhvdXQgdG91Y2hpbmcgdGhlIHJlbWFpbmluZyBub2Rlcy5cbmxldCBpc19oeWRyYXRpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHN0YXJ0X2h5ZHJhdGluZygpIHtcbiAgICBpc19oeWRyYXRpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gZW5kX2h5ZHJhdGluZygpIHtcbiAgICBpc19oeWRyYXRpbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwcGVyX2JvdW5kKGxvdywgaGlnaCwga2V5LCB2YWx1ZSkge1xuICAgIC8vIFJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZSBsYXJnZXIgdGhhbiBpbnB1dCB2YWx1ZSBpbiB0aGUgcmFuZ2UgW2xvdywgaGlnaClcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuICAgICAgICBpZiAoa2V5KG1pZCkgPD0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG59XG5mdW5jdGlvbiBpbml0X2h5ZHJhdGUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oeWRyYXRlX2luaXQpXG4gICAgICAgIHJldHVybjtcbiAgICB0YXJnZXQuaHlkcmF0ZV9pbml0ID0gdHJ1ZTtcbiAgICAvLyBXZSBrbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgY2xhaW1fb3JkZXIgdmFsdWVzIHNpbmNlIHRoZSB1bmNsYWltZWQgaGF2ZSBiZWVuIGRldGFjaGVkIGlmIHRhcmdldCBpcyBub3QgPGhlYWQ+XG4gICAgbGV0IGNoaWxkcmVuID0gdGFyZ2V0LmNoaWxkTm9kZXM7XG4gICAgLy8gSWYgdGFyZ2V0IGlzIDxoZWFkPiwgdGhlcmUgbWF5IGJlIGNoaWxkcmVuIHdpdGhvdXQgY2xhaW1fb3JkZXJcbiAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnSEVBRCcpIHtcbiAgICAgICAgY29uc3QgbXlDaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXlDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gbXlDaGlsZHJlbjtcbiAgICB9XG4gICAgLypcbiAgICAqIFJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkuXG4gICAgKiBXZSBjYW4gcmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseSBieSBmaW5kaW5nIHRoZSBsb25nZXN0IHN1YnNlcXVlbmNlIG9mXG4gICAgKiBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGNsYWltZWQgaW4gb3JkZXIgYW5kIG9ubHkgbW92aW5nIHRoZSByZXN0LiBUaGUgbG9uZ2VzdFxuICAgICogc3Vic2VxdWVuY2Ugc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgdGhhdCBhcmUgY2xhaW1lZCBpbiBvcmRlciBjYW4gYmUgZm91bmQgYnlcbiAgICAqIGNvbXB1dGluZyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIC5jbGFpbV9vcmRlciB2YWx1ZXMuXG4gICAgKlxuICAgICogVGhpcyBhbGdvcml0aG0gaXMgb3B0aW1hbCBpbiBnZW5lcmF0aW5nIHRoZSBsZWFzdCBhbW91bnQgb2YgcmVvcmRlciBvcGVyYXRpb25zXG4gICAgKiBwb3NzaWJsZS5cbiAgICAqXG4gICAgKiBQcm9vZjpcbiAgICAqIFdlIGtub3cgdGhhdCwgZ2l2ZW4gYSBzZXQgb2YgcmVvcmRlcmluZyBvcGVyYXRpb25zLCB0aGUgbm9kZXMgdGhhdCBkbyBub3QgbW92ZVxuICAgICogYWx3YXlzIGZvcm0gYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSwgc2luY2UgdGhleSBkbyBub3QgbW92ZSBhbW9uZyBlYWNoIG90aGVyXG4gICAgKiBtZWFuaW5nIHRoYXQgdGhleSBtdXN0IGJlIGFscmVhZHkgb3JkZXJlZCBhbW9uZyBlYWNoIG90aGVyLiBUaHVzLCB0aGUgbWF4aW1hbFxuICAgICogc2V0IG9mIG5vZGVzIHRoYXQgZG8gbm90IG1vdmUgZm9ybSBhIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZS5cbiAgICAqL1xuICAgIC8vIENvbXB1dGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgLy8gbTogc3Vic2VxdWVuY2UgbGVuZ3RoIGogPT4gaW5kZXggayBvZiBzbWFsbGVzdCB2YWx1ZSB0aGF0IGVuZHMgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggalxuICAgIGNvbnN0IG0gPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGggKyAxKTtcbiAgICAvLyBQcmVkZWNlc3NvciBpbmRpY2VzICsgMVxuICAgIGNvbnN0IHAgPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGgpO1xuICAgIG1bMF0gPSAtMTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gY2hpbGRyZW5baV0uY2xhaW1fb3JkZXI7XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3Qgc3Vic2VxdWVuY2UgbGVuZ3RoIHN1Y2ggdGhhdCBpdCBlbmRzIGluIGEgdmFsdWUgbGVzcyB0aGFuIG91ciBjdXJyZW50IHZhbHVlXG4gICAgICAgIC8vIHVwcGVyX2JvdW5kIHJldHVybnMgZmlyc3QgZ3JlYXRlciB2YWx1ZSwgc28gd2Ugc3VidHJhY3Qgb25lXG4gICAgICAgIC8vIHdpdGggZmFzdCBwYXRoIGZvciB3aGVuIHdlIGFyZSBvbiB0aGUgY3VycmVudCBsb25nZXN0IHN1YnNlcXVlbmNlXG4gICAgICAgIGNvbnN0IHNlcUxlbiA9ICgobG9uZ2VzdCA+IDAgJiYgY2hpbGRyZW5bbVtsb25nZXN0XV0uY2xhaW1fb3JkZXIgPD0gY3VycmVudCkgPyBsb25nZXN0ICsgMSA6IHVwcGVyX2JvdW5kKDEsIGxvbmdlc3QsIGlkeCA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuICAgICAgICBwW2ldID0gbVtzZXFMZW5dICsgMTtcbiAgICAgICAgY29uc3QgbmV3TGVuID0gc2VxTGVuICsgMTtcbiAgICAgICAgLy8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuICAgICAgICBtW25ld0xlbl0gPSBpO1xuICAgICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmV3TGVuLCBsb25nZXN0KTtcbiAgICB9XG4gICAgLy8gVGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBub2RlcyAoaW5pdGlhbGx5IHJldmVyc2VkKVxuICAgIGNvbnN0IGxpcyA9IFtdO1xuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBub2Rlcywgbm9kZXMgdGhhdCB3aWxsIGJlIG1vdmVkXG4gICAgY29uc3QgdG9Nb3ZlID0gW107XG4gICAgbGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGN1ciA9IG1bbG9uZ2VzdF0gKyAxOyBjdXIgIT0gMDsgY3VyID0gcFtjdXIgLSAxXSkge1xuICAgICAgICBsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG4gICAgICAgIGZvciAoOyBsYXN0ID49IGN1cjsgbGFzdC0tKSB7XG4gICAgICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC0tO1xuICAgIH1cbiAgICBmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcbiAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgIH1cbiAgICBsaXMucmV2ZXJzZSgpO1xuICAgIC8vIFdlIHNvcnQgdGhlIG5vZGVzIGJlaW5nIG1vdmVkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZWlyIGluc2VydGlvbiBvcmRlciBtYXRjaGVzIHRoZSBjbGFpbSBvcmRlclxuICAgIHRvTW92ZS5zb3J0KChhLCBiKSA9PiBhLmNsYWltX29yZGVyIC0gYi5jbGFpbV9vcmRlcik7XG4gICAgLy8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b01vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2hpbGUgKGogPCBsaXMubGVuZ3RoICYmIHRvTW92ZVtpXS5jbGFpbV9vcmRlciA+PSBsaXNbal0uY2xhaW1fb3JkZXIpIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmNob3IgPSBqIDwgbGlzLmxlbmd0aCA/IGxpc1tqXSA6IG51bGw7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUodG9Nb3ZlW2ldLCBhbmNob3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHRhcmdldCwgc3R5bGVfc2hlZXRfaWQsIHN0eWxlcykge1xuICAgIGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcbiAgICBpZiAoIWFwcGVuZF9zdHlsZXNfdG8uZ2V0RWxlbWVudEJ5SWQoc3R5bGVfc2hlZXRfaWQpKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuaWQgPSBzdHlsZV9zaGVldF9pZDtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZXM7XG4gICAgICAgIGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSkge1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIGNvbnN0IHJvb3QgPSBub2RlLmdldFJvb3ROb2RlID8gbm9kZS5nZXRSb290Tm9kZSgpIDogbm9kZS5vd25lckRvY3VtZW50O1xuICAgIGlmIChyb290ICYmIHJvb3QuaG9zdCkge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZV9lbGVtZW50ID0gZWxlbWVudCgnc3R5bGUnKTtcbiAgICBhcHBlbmRfc3R5bGVzaGVldChnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSksIHN0eWxlX2VsZW1lbnQpO1xuICAgIHJldHVybiBzdHlsZV9lbGVtZW50LnNoZWV0O1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlc2hlZXQobm9kZSwgc3R5bGUpIHtcbiAgICBhcHBlbmQobm9kZS5oZWFkIHx8IG5vZGUsIHN0eWxlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZykge1xuICAgICAgICBpbml0X2h5ZHJhdGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkKSB8fCAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50RWxlbWVudCAhPT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcbiAgICAgICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlbGYoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcylcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC5pc1RydXN0ZWQpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSAhPT0gdmFsdWUpXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yc1trZXldICYmIGRlc2NyaXB0b3JzW2tleV0uc2V0KSB7XG4gICAgICAgICAgICBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChwcm9wIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChncm91cFtpXS5jaGVja2VkKVxuICAgICAgICAgICAgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgdmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcbiAgICBpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3NOb2RlLCBjcmVhdGVOb2RlLCBkb250VXBkYXRlTGFzdEluZGV4ID0gZmFsc2UpIHtcbiAgICAvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgcmVzdWx0Tm9kZSA9ICgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHJldHVybiBjcmVhdGVOb2RlKCk7XG4gICAgfSkoKTtcbiAgICByZXN1bHROb2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIHJldHVybiByZXN1bHROb2RlO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSwgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5mb3JFYWNoKHYgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sICgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMywgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9ICcnICsgZGF0YTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFTdHIpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YVN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVN0cjtcbiAgICAgICAgfVxuICAgIH0sICgpID0+IHRleHQoZGF0YSksIHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5mdW5jdGlvbiBmaW5kX2NvbW1lbnQobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG4gICAgLy8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG4gICAgY29uc3Qgc3RhcnRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuICAgIGNvbnN0IGVuZF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4KTtcbiAgICBpZiAoc3RhcnRfaW5kZXggPT09IGVuZF9pbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24odW5kZWZpbmVkLCBpc19zdmcpO1xuICAgIH1cbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcbiAgICAgICAgbi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihjbGFpbWVkX25vZGVzLCBpc19zdmcpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ICE9PSBkYXRhKVxuICAgICAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJykgfHwgc2VsZWN0Lm9wdGlvbnNbMF07XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG4gICAgICAgICdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnRhYkluZGV4ID0gLTE7XG4gICAgY29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKHdpbmRvdywgJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kKG5vZGUsIGlmcmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaChpZnJhbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5mdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCBkZXRhaWwpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cbmNsYXNzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgIH1cbiAgICBtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfc3ZnKVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHN2Z19lbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgICBoKGh0bWwpIHtcbiAgICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHRoaXMubiA9IEFycmF5LmZyb20odGhpcy5lLmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHAoaHRtbCkge1xuICAgICAgICB0aGlzLmQoKTtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgICB0aGlzLmkodGhpcy5hKTtcbiAgICB9XG4gICAgZCgpIHtcbiAgICAgICAgdGhpcy5uLmZvckVhY2goZGV0YWNoKTtcbiAgICB9XG59XG5jbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoY2xhaW1lZF9ub2RlcywgaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoaXNfc3ZnKTtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sID0gY2xhaW1lZF9ub2RlcztcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIGlmICh0aGlzLmwpIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHRoaXMubDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICByZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGZvciBtdWx0aXBsZSBkb2N1bWVudHMgYmVjYXVzZSBhIFN2ZWx0ZSBhcHBsaWNhdGlvbiBjb3VsZCBhbHNvIGNvbnRhaW4gaWZyYW1lc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMzYyNFxuY29uc3QgbWFuYWdlZF9zdHlsZXMgPSBuZXcgTWFwKCk7XG5sZXQgYWN0aXZlID0gMDtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIGxldCBoYXNoID0gNTM4MTtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5mdW5jdGlvbiBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKSB7XG4gICAgY29uc3QgaW5mbyA9IHsgc3R5bGVzaGVldDogYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSksIHJ1bGVzOiB7fSB9O1xuICAgIG1hbmFnZWRfc3R5bGVzLnNldChkb2MsIGluZm8pO1xuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbiwgdWlkID0gMCkge1xuICAgIGNvbnN0IHN0ZXAgPSAxNi42NjYgLyBkdXJhdGlvbjtcbiAgICBsZXQga2V5ZnJhbWVzID0gJ3tcXG4nO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuICAgICAgICBjb25zdCB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuICAgICAgICBrZXlmcmFtZXMgKz0gcCAqIDEwMCArIGAleyR7Zm4odCwgMSAtIHQpfX1cXG5gO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0ga2V5ZnJhbWVzICsgYDEwMCUgeyR7Zm4oYiwgMSAtIGIpfX1cXG59YDtcbiAgICBjb25zdCBuYW1lID0gYF9fc3ZlbHRlXyR7aGFzaChydWxlKX1fJHt1aWR9YDtcbiAgICBjb25zdCBkb2MgPSBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSk7XG4gICAgY29uc3QgeyBzdHlsZXNoZWV0LCBydWxlcyB9ID0gbWFuYWdlZF9zdHlsZXMuZ2V0KGRvYykgfHwgY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSk7XG4gICAgaWYgKCFydWxlc1tuYW1lXSkge1xuICAgICAgICBydWxlc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShgQGtleWZyYW1lcyAke25hbWV9ICR7cnVsZX1gLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnO1xuICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gYCR7YW5pbWF0aW9uID8gYCR7YW5pbWF0aW9ufSwgYCA6ICcnfSR7bmFtZX0gJHtkdXJhdGlvbn1tcyBsaW5lYXIgJHtkZWxheX1tcyAxIGJvdGhgO1xuICAgIGFjdGl2ZSArPSAxO1xuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZGVsZXRlX3J1bGUobm9kZSwgbmFtZSkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCBuZXh0ID0gcHJldmlvdXMuZmlsdGVyKG5hbWVcbiAgICAgICAgPyBhbmltID0+IGFuaW0uaW5kZXhPZihuYW1lKSA8IDAgLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICA6IGFuaW0gPT4gYW5pbS5pbmRleE9mKCdfX3N2ZWx0ZScpID09PSAtMSAvLyByZW1vdmUgYWxsIFN2ZWx0ZSBhbmltYXRpb25zXG4gICAgKTtcbiAgICBjb25zdCBkZWxldGVkID0gcHJldmlvdXMubGVuZ3RoIC0gbmV4dC5sZW5ndGg7XG4gICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG4gICAgICAgIGFjdGl2ZSAtPSBkZWxldGVkO1xuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNsZWFyX3J1bGVzKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFuYWdlZF9zdHlsZXMuZm9yRWFjaChpbmZvID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3R5bGVzaGVldCB9ID0gaW5mbztcbiAgICAgICAgICAgIGxldCBpID0gc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQuZGVsZXRlUnVsZShpKTtcbiAgICAgICAgICAgIGluZm8ucnVsZXMgPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgIHJldHVybiAodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgLy8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgLy8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgfSk7XG4gICAgICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG5mdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cbmZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5jb25zdCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5mdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuICAgIGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBkbyB7XG4gICAgICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgLy8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG4gICAgICAgIHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcbiAgICAgICAgICAgIGZsdXNoaWR4Kys7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICB9XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgc2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfVxuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgICAgICBjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICAgICAkJC5kaXJ0eSA9IFstMV07XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgIH1cbn1cblxubGV0IHByb21pc2U7XG5mdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5sZXQgb3V0cm9zO1xuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICAgIG91dHJvcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgYzogW10sXG4gICAgICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICAgIGlmICghb3V0cm9zLnIpIHtcbiAgICAgICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gICAgfVxuICAgIG91dHJvcyA9IG91dHJvcy5wO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICBibG9jay5pKGxvY2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2subykge1xuICAgICAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cm9pbmcuYWRkKGJsb2NrKTtcbiAgICAgICAgb3V0cm9zLmMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZCgxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2subyhsb2NhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gZmFsc2U7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB1aWQgPSAwO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBpZiAodGFzaylcbiAgICAgICAgICAgIHRhc2suYWJvcnQoKTtcbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgY29uc3QgZ3JvdXAgPSBvdXRyb3M7XG4gICAgZ3JvdXAuciArPSAxO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG4gICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tZ3JvdXAucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxIC0gdCwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kKHJlc2V0KSB7XG4gICAgICAgICAgICBpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcudGljaygxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgdCA9IGludHJvID8gMCA6IDE7XG4gICAgbGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcbiAgICBmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuICAgICAgICBjb25zdCBkID0gKHByb2dyYW0uYiAtIHQpO1xuICAgICAgICBkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IHQsXG4gICAgICAgICAgICBiOiBwcm9ncmFtLmIsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydDogcHJvZ3JhbS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuICAgICAgICAgICAgZ3JvdXA6IHByb2dyYW0uZ3JvdXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oYikge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG5vdygpICsgZGVsYXksXG4gICAgICAgICAgICBiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG4gICAgICAgICAgICBvdXRyb3MuciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuICAgICAgICAgICAgLy8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuICAgICAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIHJ1bm5pbmdfcHJvZ3JhbS5iLCBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sIDAsIGVhc2luZywgY29uZmlnLmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iLCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludHJvIOKAlCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91dHJvIOKAlCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJ1bihiKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuICAgIGNvbnN0IHRva2VuID0gaW5mby50b2tlbiA9IHt9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0eXBlLCBpbmRleCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5mby50b2tlbiAhPT0gdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSB2YWx1ZTtcbiAgICAgICAgbGV0IGNoaWxkX2N0eCA9IGluZm8uY3R4O1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHR5cGUgJiYgKGluZm8uY3VycmVudCA9IHR5cGUpKGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5mby5ibG9jaykge1xuICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4ICYmIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9jay5kKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgICAgICBibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuICAgICAgICAgICAgbmVlZHNfZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uYmxvY2sgPSBibG9jaztcbiAgICAgICAgaWYgKGluZm8uYmxvY2tzKVxuICAgICAgICAgICAgaW5mby5ibG9ja3NbaW5kZXhdID0gYmxvY2s7XG4gICAgICAgIGlmIChuZWVkc19mbHVzaCkge1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNfcHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50X2NvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgICAgICBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgICAgICBpZiAoIWluZm8uaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnJlc29sdmVkID0gcHJvbWlzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoKGluZm8sIGN0eCwgZGlydHkpIHtcbiAgICBjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmVkIH0gPSBpbmZvO1xuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8udGhlbikge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby52YWx1ZV0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby5lcnJvcl0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaW5mby5ibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xufVxuXG5jb25zdCBnbG9iYWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgOiBnbG9iYWwpO1xuXG5mdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5kKDEpO1xuICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2gob2xkX2Jsb2NrcywgZGlydHksIGdldF9rZXksIGR5bmFtaWMsIGN0eCwgbGlzdCwgbG9va3VwLCBub2RlLCBkZXN0cm95LCBjcmVhdGVfZWFjaF9ibG9jaywgbmV4dCwgZ2V0X2NvbnRleHQpIHtcbiAgICBsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGkgPSBvO1xuICAgIGNvbnN0IG9sZF9pbmRleGVzID0ge307XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcbiAgICBjb25zdCBuZXdfYmxvY2tzID0gW107XG4gICAgY29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG4gICAgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfbG9va3VwLnNldChrZXksIG5ld19ibG9ja3NbaV0gPSBibG9jayk7XG4gICAgICAgIGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpXG4gICAgICAgICAgICBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgYmxvY2subShub2RlLCBuZXh0KTtcbiAgICAgICAgbG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcbiAgICAgICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgICAgICBuLS07XG4gICAgfVxuICAgIHdoaWxlIChvICYmIG4pIHtcbiAgICAgICAgY29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgICAgICBjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICAgICAgY29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG4gICAgICAgIGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgbmV4dCA9IG5ld19ibG9jay5maXJzdDtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG8tLSkge1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgICAgICBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKVxuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgfVxuICAgIHdoaWxlIChuKVxuICAgICAgICBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuICAgIHJldHVybiBuZXdfYmxvY2tzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2gnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG4gICAgY29uc3QgdXBkYXRlID0ge307XG4gICAgY29uc3QgdG9fbnVsbF9vdXQgPSB7fTtcbiAgICBjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG4gICAgbGV0IGkgPSBsZXZlbHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgbyA9IGxldmVsc1tpXTtcbiAgICAgICAgY29uc3QgbiA9IHVwZGF0ZXNbaV07XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG4pKVxuICAgICAgICAgICAgICAgICAgICB0b19udWxsX291dFtrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRlZF9mb3Jba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVba2V5XSA9IG5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbHNbaV0gPSBuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9fbnVsbF9vdXQpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHVwZGF0ZSkpXG4gICAgICAgICAgICB1cGRhdGVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGdldF9zcHJlYWRfb2JqZWN0KHNwcmVhZF9wcm9wcykge1xuICAgIHJldHVybiB0eXBlb2Ygc3ByZWFkX3Byb3BzID09PSAnb2JqZWN0JyAmJiBzcHJlYWRfcHJvcHMgIT09IG51bGwgPyBzcHJlYWRfcHJvcHMgOiB7fTtcbn1cblxuLy8gc291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbmNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgICdhbGxvd2Z1bGxzY3JlZW4nLFxuICAgICdhbGxvd3BheW1lbnRyZXF1ZXN0JyxcbiAgICAnYXN5bmMnLFxuICAgICdhdXRvZm9jdXMnLFxuICAgICdhdXRvcGxheScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdjb250cm9scycsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZm9ybW5vdmFsaWRhdGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpc21hcCcsXG4gICAgJ2xvb3AnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ211dGVkJyxcbiAgICAnbm9tb2R1bGUnLFxuICAgICdub3ZhbGlkYXRlJyxcbiAgICAnb3BlbicsXG4gICAgJ3BsYXlzaW5saW5lJyxcbiAgICAncmVhZG9ubHknLFxuICAgICdyZXF1aXJlZCcsXG4gICAgJ3JldmVyc2VkJyxcbiAgICAnc2VsZWN0ZWQnXG5dKTtcblxuY29uc3Qgdm9pZF9lbGVtZW50X25hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkLztcbmZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuICAgIHJldHVybiB2b2lkX2VsZW1lbnRfbmFtZXMudGVzdChuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGF0dHJzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoYXR0cnNfdG9fYWRkKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlc190b19hZGQgPSBhdHRyc190b19hZGQuc3R5bGVzO1xuICAgICAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBtZXJnZV9zc3Jfc3R5bGVzKHN0eWxlX2F0dHJpYnV0ZSwgc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgY29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG4gICAgICAgIGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKDAsIGNvbG9uX2luZGV4KS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVfZGlyZWN0aXZlW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG4vKipcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBhbmQgaGFzIGJlZW4gb3B0aW1pemVkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvNTcwMVxuICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGVzY2FwZWQgPSAnJztcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGNoID0gc3RyW2ldO1xuICAgICAgICBlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiAoY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7JykpO1xuICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcbiAgICAvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuICAgIGNvbnN0IHNob3VsZF9lc2NhcGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzYCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBkZWJ1ZyhmaWxlLCBsaW5lLCBjb2x1bW4sIHZhbHVlcykge1xuICAgIGNvbnNvbGUubG9nKGB7QGRlYnVnfSAke2ZpbGUgPyBmaWxlICsgJyAnIDogJyd9KCR7bGluZX06JHtjb2x1bW59KWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4gJyc7XG59XG5sZXQgb25fZGVzdHJveTtcbmZ1bmN0aW9uIGNyZWF0ZV9zc3JfY29tcG9uZW50KGZuKSB7XG4gICAgZnVuY3Rpb24gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICAgICAgY29uc3QgJCQgPSB7XG4gICAgICAgICAgICBvbl9kZXN0cm95LFxuICAgICAgICAgICAgY29udGV4dDogbmV3IE1hcChjb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZGlzY2FyZGVkXG4gICAgICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpXG4gICAgICAgIH07XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudCh7ICQkIH0pO1xuICAgICAgICBjb25zdCBodG1sID0gZm4ocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzKTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyOiAocHJvcHMgPSB7fSwgeyAkJHNsb3RzID0ge30sIGNvbnRleHQgPSBuZXcgTWFwKCkgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBvbl9kZXN0cm95ID0gW107XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHRpdGxlOiAnJywgaGVhZDogJycsIGNzczogbmV3IFNldCgpIH07XG4gICAgICAgICAgICBjb25zdCBodG1sID0gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywge30sICQkc2xvdHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcnVuX2FsbChvbl9kZXN0cm95KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHRtbCxcbiAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogQXJyYXkuZnJvbShyZXN1bHQuY3NzKS5tYXAoY3NzID0+IGNzcy5jb2RlKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBudWxsIC8vIFRPRE9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWQ6IHJlc3VsdC50aXRsZSArIHJlc3VsdC5oZWFkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAkJHJlbmRlclxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRfYXR0cmlidXRlKG5hbWUsIHZhbHVlLCBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGJvb2xlYW4gJiYgIXZhbHVlKSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IGFzc2lnbm1lbnQgPSAoYm9vbGVhbiAmJiB2YWx1ZSA9PT0gdHJ1ZSkgPyAnJyA6IGA9XCIke2VzY2FwZSh2YWx1ZSwgdHJ1ZSl9XCJgO1xuICAgIHJldHVybiBgICR7bmFtZX0ke2Fzc2lnbm1lbnR9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogJyc7XG59XG5mdW5jdGlvbiBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZV9vYmplY3QpXG4gICAgICAgIC5maWx0ZXIoa2V5ID0+IHN0eWxlX29iamVjdFtrZXldKVxuICAgICAgICAubWFwKGtleSA9PiBgJHtrZXl9OiAke3N0eWxlX29iamVjdFtrZXldfTtgKVxuICAgICAgICAuam9pbignICcpO1xufVxuZnVuY3Rpb24gYWRkX3N0eWxlcyhzdHlsZV9vYmplY3QpIHtcbiAgICBjb25zdCBzdHlsZXMgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCk7XG4gICAgcmV0dXJuIHN0eWxlcyA/IGAgc3R5bGU9XCIke3N0eWxlc31cImAgOiAnJztcbn1cblxuZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQuJCQucHJvcHNbbmFtZV07XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LiQkLmJvdW5kW2luZGV4XSA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuICAgIGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG4gICAgYmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IsIGN1c3RvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50LCBvbl9tb3VudCwgb25fZGVzdHJveSwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG4gICAgZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgaWYgKCFjdXN0b21FbGVtZW50KSB7XG4gICAgICAgIC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdfb25fZGVzdHJveSA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICBpZiAob25fZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIG9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuICAgICAgICAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcbiAgICAgICAgJCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgJCQuY3R4ID0gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcbiAgICBpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuICAgIH1cbiAgICBjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAoMSA8PCAoaSAlIDMxKSk7XG59XG5mdW5jdGlvbiBpbml0KGNvbXBvbmVudCwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgbm90X2VxdWFsLCBwcm9wcywgYXBwZW5kX3N0eWxlcywgZGlydHkgPSBbLTFdKSB7XG4gICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgY3R4OiBudWxsLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgY29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgZGlydHksXG4gICAgICAgIHNraXBfYm91bmQ6IGZhbHNlLFxuICAgICAgICByb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3RcbiAgICB9O1xuICAgIGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcbiAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAkJC5jdHggPSBpbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG4gICAgICAgICAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICQkLmN0eFtpXSA9IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSlcbiAgICAgICAgICAgICAgICAgICAgJCQuYm91bmRbaV0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSlcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSlcbiAgICAgICAgOiBbXTtcbiAgICAkJC51cGRhdGUoKTtcbiAgICByZWFkeSA9IHRydWU7XG4gICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcbiAgICAkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0X2h5ZHJhdGluZygpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IsIG9wdGlvbnMuY3VzdG9tRWxlbWVudCk7XG4gICAgICAgIGVuZF9oeWRyYXRpbmcoKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgU3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25fbW91bnQgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgICB0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodGhpcy4kJC5vbl9kaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCBPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogJzMuNDkuMCcgfSwgZGV0YWlsKSwgeyBidWJibGVzOiB0cnVlIH0pKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcbiAgICBkZXRhY2gobm9kZSk7XG59XG5mdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3Rlbl9kZXYobm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMsIGhhc19wcmV2ZW50X2RlZmF1bHQsIGhhc19zdG9wX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICBjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuICAgIGlmICh0YWcgJiYgIWlzX3N0cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxzdmVsdGU6ZWxlbWVudD4gZXhwZWN0cyBcInRoaXNcIiBhdHRyaWJ1dGUgdG8gYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgaWYgKHRhZyAmJiBpc192b2lkKHRhZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPiBpcyBzZWxmLWNsb3NpbmcgYW5kIGNhbm5vdCBoYXZlIGNvbnRlbnQuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgU3ZlbHRlQ29tcG9uZW50LCBTdmVsdGVDb21wb25lbnREZXYsIFN2ZWx0ZUNvbXBvbmVudFR5cGVkLCBTdmVsdGVFbGVtZW50LCBhY3Rpb25fZGVzdHJveWVyLCBhZGRfYXR0cmlidXRlLCBhZGRfY2xhc3NlcywgYWRkX2ZsdXNoX2NhbGxiYWNrLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9yZXNpemVfbGlzdGVuZXIsIGFkZF9zdHlsZXMsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGlkZW50aXR5LCBpbml0LCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGlzX3ZvaWQsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWVyZ2Vfc3NyX3N0eWxlcywgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9kYXRhLCBzZXRfZGF0YV9kZXYsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9wcm9wYWdhdGlvbiwgc3Vic2NyaWJlLCBzdmdfZWxlbWVudCwgdGV4dCwgdGljaywgdGltZV9yYW5nZXNfdG9fYXJyYXksIHRvX251bWJlciwgdG9nZ2xlX2NsYXNzLCB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCwgdHJ1c3RlZCwgdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaCwgdXBkYXRlX2tleWVkX2VhY2gsIHVwZGF0ZV9zbG90LCB1cGRhdGVfc2xvdF9iYXNlLCB2YWxpZGF0ZV9jb21wb25lbnQsIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCwgdmFsaWRhdGVfZWFjaF9hcmd1bWVudCwgdmFsaWRhdGVfZWFjaF9rZXlzLCB2YWxpZGF0ZV9zbG90cywgdmFsaWRhdGVfc3RvcmUsIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50LCB4bGlua19hdHRyIH07XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG5cbiAgZXhwb3J0IGxldCBjb25maWcsIHN0ZXA7XG4gIGxldCBhY3Rpb24sIGNsYXNzZXMsIGRpc2FibGVkLCBsYWJlbCwgc2Vjb25kYXJ5LCB0ZXh0O1xuXG4gICQ6IHtcbiAgICBhY3Rpb24gPSBjb25maWcuYWN0aW9uID8gY29uZmlnLmFjdGlvbi5iaW5kKHN0ZXAudG91cikgOiBudWxsO1xuICAgIGNsYXNzZXMgPSBjb25maWcuY2xhc3NlcztcbiAgICBkaXNhYmxlZCA9IGNvbmZpZy5kaXNhYmxlZCA/IGdldENvbmZpZ09wdGlvbihjb25maWcuZGlzYWJsZWQpIDogZmFsc2U7XG4gICAgbGFiZWwgPSBjb25maWcubGFiZWwgPyBnZXRDb25maWdPcHRpb24oY29uZmlnLmxhYmVsKSA6IG51bGw7XG4gICAgc2Vjb25kYXJ5ID0gY29uZmlnLnNlY29uZGFyeTtcbiAgICB0ZXh0ID0gY29uZmlnLnRleHQgPyBnZXRDb25maWdPcHRpb24oY29uZmlnLnRleHQpIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbmZpZ09wdGlvbihvcHRpb24pIHtcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb24pKSB7XG4gICAgICByZXR1cm4gb3B0aW9uID0gb3B0aW9uLmNhbGwoc3RlcCk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG4gIH1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1idXR0b24ge1xuICAgIGJhY2tncm91bmQ6IHJnYig1MCwgMTM2LCAyMzApO1xuICAgIGJvcmRlcjogMDtcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSk7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIG1hcmdpbi1yaWdodDogMC41cmVtO1xuICAgIHBhZGRpbmc6IDAuNXJlbSAxLjVyZW07XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b246bm90KDpkaXNhYmxlZCk6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHJnYigyNSwgMTExLCAyMDQpO1xuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbi5zaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5IHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjQxLCAyNDIsIDI0Myk7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uLnNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnk6bm90KDpkaXNhYmxlZCk6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHJnYigyMTQsIDIxNywgMjE5KTtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b246ZGlzYWJsZWQge1xuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gIH1cbjwvc3R5bGU+XG5cbjxidXR0b25cbiAgYXJpYS1sYWJlbD1cIntsYWJlbCA/IGxhYmVsIDogbnVsbH1cIlxuICBjbGFzcz1cIntgJHsoY2xhc3NlcyB8fCAnJyl9IHNoZXBoZXJkLWJ1dHRvbiAkeyhzZWNvbmRhcnkgPyAnc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeScgOiAnJyl9YH1cIlxuICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gIG9uOmNsaWNrPXthY3Rpb259XG4gIHRhYmluZGV4PVwiMFwiXG4+XG4gICAge0BodG1sIHRleHR9XG48L2J1dHRvbj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZEJ1dHRvbiBmcm9tICcuL3NoZXBoZXJkLWJ1dHRvbi5zdmVsdGUnO1xuXG4gIGV4cG9ydCBsZXQgc3RlcDtcblxuICAkOiBidXR0b25zID0gc3RlcC5vcHRpb25zLmJ1dHRvbnM7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWZvb3RlciB7XG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNXB4O1xuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA1cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIHBhZGRpbmc6IDAgMC43NXJlbSAwLjc1cmVtO1xuICB9XG5cbiAgLnNoZXBoZXJkLWZvb3RlciAuc2hlcGhlcmQtYnV0dG9uOmxhc3QtY2hpbGQge1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGZvb3RlciBjbGFzcz1cInNoZXBoZXJkLWZvb3RlclwiPlxuICAgIHsjaWYgYnV0dG9uc31cbiAgICAgICAgeyNlYWNoIGJ1dHRvbnMgYXMgY29uZmlnfVxuICAgICAgICAgIDxTaGVwaGVyZEJ1dHRvblxuICAgICAgICAgICAge2NvbmZpZ31cbiAgICAgICAgICAgIHtzdGVwfVxuICAgICAgICAgIC8+XG4gICAgICAgIHsvZWFjaH1cbiAgICB7L2lmfVxuPC9mb290ZXI+XG4iLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGNhbmNlbEljb24sIHN0ZXA7XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNsaWNrIGxpc3RlbmVyIHRvIHRoZSBjYW5jZWwgbGluayB0aGF0IGNhbmNlbHMgdGhlIHRvdXJcbiAgICovXG4gIGNvbnN0IGhhbmRsZUNhbmNlbENsaWNrID0gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgc3RlcC5jYW5jZWwoKTtcbiAgfTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtY2FuY2VsLWljb24ge1xuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBjb2xvcjogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjc1KTtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICB0cmFuc2l0aW9uOiBjb2xvciAwLjVzIGVhc2U7XG4gIH1cblxuICAuc2hlcGhlcmQtY2FuY2VsLWljb246aG92ZXIge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtY2FuY2VsLWljb24ge1xuICAgIGNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtY2FuY2VsLWljb246aG92ZXIge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG48L3N0eWxlPlxuXG48YnV0dG9uXG4gIGFyaWEtbGFiZWw9XCJ7Y2FuY2VsSWNvbi5sYWJlbCA/IGNhbmNlbEljb24ubGFiZWwgOiAnQ2xvc2UgVG91cid9XCJcbiAgY2xhc3M9XCJzaGVwaGVyZC1jYW5jZWwtaWNvblwiXG4gIG9uOmNsaWNrPXtoYW5kbGVDYW5jZWxDbGlja31cbiAgdHlwZT1cImJ1dHRvblwiXG4+XG4gIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG48L2J1dHRvbj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuICBcbiAgZXhwb3J0IGxldCBsYWJlbElkLCBlbGVtZW50LCB0aXRsZTtcbiAgXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aXRsZSkpIHtcbiAgICAgIHRpdGxlID0gdGl0bGUoKTtcbiAgICB9XG4gICAgXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSB0aXRsZTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLXRpdGxlIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgIGZsZXg6IDEgMCBhdXRvO1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG48L3N0eWxlPlxuXG48aDNcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBpZD1cIntsYWJlbElkfVwiXG4gIGNsYXNzPVwic2hlcGhlcmQtdGl0bGVcIlxuPlxuPC9oMz5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZENhbmNlbEljb24gZnJvbSAnLi9zaGVwaGVyZC1jYW5jZWwtaWNvbi5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRUaXRsZSBmcm9tICcuL3NoZXBoZXJkLXRpdGxlLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBsYWJlbElkLCBzdGVwO1xuICBsZXQgdGl0bGUsIGNhbmNlbEljb247XG5cbiAgJDoge1xuICAgICAgdGl0bGUgPSBzdGVwLm9wdGlvbnMudGl0bGU7XG4gICAgICBjYW5jZWxJY29uID0gc3RlcC5vcHRpb25zLmNhbmNlbEljb247XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtaGVhZGVyIHtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDVweDtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNXB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICBsaW5lLWhlaWdodDogMmVtO1xuICAgIHBhZGRpbmc6IDAuNzVyZW0gMC43NXJlbSAwO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtaGVhZGVyIHtcbiAgICBiYWNrZ3JvdW5kOiAjZTZlNmU2O1xuICAgIHBhZGRpbmc6IDFlbTtcbiAgfVxuPC9zdHlsZT5cblxuPGhlYWRlciBjbGFzcz1cInNoZXBoZXJkLWhlYWRlclwiPlxuICAgIHsjaWYgdGl0bGV9XG4gICAgICA8U2hlcGhlcmRUaXRsZVxuICAgICAgICB7bGFiZWxJZH1cbiAgICAgICAge3RpdGxlfVxuICAgICAgLz5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBjYW5jZWxJY29uICYmIGNhbmNlbEljb24uZW5hYmxlZH1cbiAgICAgIDxTaGVwaGVyZENhbmNlbEljb25cbiAgICAgICAge2NhbmNlbEljb259XG4gICAgICAgIHtzdGVwfVxuICAgICAgLz5cbiAgICB7L2lmfVxuPC9oZWFkZXI+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcblxuICBleHBvcnQgbGV0IGRlc2NyaXB0aW9uSWQsIGVsZW1lbnQsIHN0ZXA7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGxldCB7IHRleHQgfSA9IHN0ZXAub3B0aW9ucztcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRleHQpKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5jYWxsKHN0ZXApO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRleHQpKSB7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IHRleHQ7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtdGV4dCB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gICAgZm9udC1zaXplOiAxcmVtO1xuICAgIGxpbmUtaGVpZ2h0OiAxLjNlbTtcbiAgICBwYWRkaW5nOiAwLjc1ZW07XG4gIH1cblxuICAuc2hlcGhlcmQtdGV4dCBwIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICB9XG5cbiAgLnNoZXBoZXJkLXRleHQgcDpsYXN0LWNoaWxkIHtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M9XCJzaGVwaGVyZC10ZXh0XCJcbiAgaWQ9XCJ7ZGVzY3JpcHRpb25JZH1cIlxuPlxuPC9kaXY+XG5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZEZvb3RlciBmcm9tICcuL3NoZXBoZXJkLWZvb3Rlci5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRIZWFkZXIgZnJvbSAnLi9zaGVwaGVyZC1oZWFkZXIuc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkVGV4dCBmcm9tICcuL3NoZXBoZXJkLXRleHQuc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrLmpzJztcblxuICBleHBvcnQgbGV0IGRlc2NyaXB0aW9uSWQsIGxhYmVsSWQsIHN0ZXA7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWNvbnRlbnQge1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgY2xhc3M9XCJzaGVwaGVyZC1jb250ZW50XCJcbj5cbiAgeyNpZiAhaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRpdGxlKSB8fCAoc3RlcC5vcHRpb25zLmNhbmNlbEljb24gJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZCl9XG4gICAgPFNoZXBoZXJkSGVhZGVyXG4gICAgICB7bGFiZWxJZH1cbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG5cbiAgeyNpZiAhaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRleHQpfVxuICAgIDxTaGVwaGVyZFRleHRcbiAgICAgIHtkZXNjcmlwdGlvbklkfVxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cblxuICB7I2lmIEFycmF5LmlzQXJyYXkoc3RlcC5vcHRpb25zLmJ1dHRvbnMpICYmIHN0ZXAub3B0aW9ucy5idXR0b25zLmxlbmd0aH1cbiAgICA8U2hlcGhlcmRGb290ZXJcbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQsIGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkQ29udGVudCBmcm9tICcuL3NoZXBoZXJkLWNvbnRlbnQuc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5cbiAgY29uc3QgS0VZX1RBQiA9IDk7XG4gIGNvbnN0IEtFWV9FU0MgPSAyNztcbiAgY29uc3QgTEVGVF9BUlJPVyA9IDM3O1xuICBjb25zdCBSSUdIVF9BUlJPVyA9IDM5O1xuXG4gIGV4cG9ydCBsZXQgY2xhc3NQcmVmaXgsIGVsZW1lbnQsIGRlc2NyaXB0aW9uSWQsIGZpcnN0Rm9jdXNhYmxlRWxlbWVudCxcbiAgICBmb2N1c2FibGVFbGVtZW50cywgbGFiZWxJZCwgbGFzdEZvY3VzYWJsZUVsZW1lbnQsIHN0ZXAsIGRhdGFTdGVwSWQ7XG5cbiAgbGV0IGhhc0NhbmNlbEljb24sIGhhc1RpdGxlLCBjbGFzc2VzO1xuXG4gICQ6IHtcbiAgICBoYXNDYW5jZWxJY29uID0gc3RlcC5vcHRpb25zICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQ7XG4gICAgaGFzVGl0bGUgPSBzdGVwLm9wdGlvbnMgJiYgc3RlcC5vcHRpb25zLnRpdGxlO1xuICB9XG5cbiAgZXhwb3J0IGNvbnN0IGdldEVsZW1lbnQgPSAoKSA9PiBlbGVtZW50O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIC8vIEdldCBhbGwgZWxlbWVudHMgdGhhdCBhcmUgZm9jdXNhYmxlXG4gICAgZGF0YVN0ZXBJZCA9IHsgW2BkYXRhLSR7Y2xhc3NQcmVmaXh9c2hlcGhlcmQtc3RlcC1pZGBdOiBzdGVwLmlkIH07XG4gICAgZm9jdXNhYmxlRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBbdGFiaW5kZXg9XCIwXCJdJyk7XG4gICAgZmlyc3RGb2N1c2FibGVFbGVtZW50ID0gZm9jdXNhYmxlRWxlbWVudHNbMF07XG4gICAgbGFzdEZvY3VzYWJsZUVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgfSk7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGlmKGNsYXNzZXMgIT09IHN0ZXAub3B0aW9ucy5jbGFzc2VzKSB7XG4gICAgICB1cGRhdGVEeW5hbWljQ2xhc3NlcygpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRHluYW1pY0NsYXNzZXMoKSB7XG4gICAgICByZW1vdmVDbGFzc2VzKGNsYXNzZXMpO1xuICAgICAgY2xhc3NlcyA9IHN0ZXAub3B0aW9ucy5jbGFzc2VzO1xuICAgICAgYWRkQ2xhc3NlcyhjbGFzc2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoY2xhc3Nlcykge1xuICAgIGlmIChpc1N0cmluZyhjbGFzc2VzKSkge1xuICAgICAgY29uc3Qgb2xkQ2xhc3NlcyA9IGdldENsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgICAgIGlmIChvbGRDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoLi4ub2xkQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgaWYoaXNTdHJpbmcoY2xhc3NlcykpIHtcbiAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gICAgICBpZiAobmV3Q2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLm5ld0NsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzZXNBcnJheShjbGFzc2VzKSB7XG4gICAgIHJldHVybiBjbGFzc2VzLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiAhIWNsYXNzTmFtZS5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGtleWRvd24gZXZlbnRzIHRvIGFsbG93IGNsb3NpbmcgdGhlIG1vZGFsIHdpdGggRVNDXG4gICAqXG4gICAqIEJvcnJvd2VkIGZyb20gdGhpcyBncmVhdCBwb3N0ISBodHRwczovL2JpdHNvZmNvLmRlL2FjY2Vzc2libGUtbW9kYWwtZGlhbG9nL1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IChlKSA9PiB7XG4gICAgY29uc3QgeyB0b3VyIH0gPSBzdGVwO1xuICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEtFWV9UQUI6XG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmQgdGFiXG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZpcnN0Rm9jdXNhYmxlRWxlbWVudCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2hlcGhlcmQtZWxlbWVudCcpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsYXN0Rm9jdXNhYmxlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gbGFzdEZvY3VzYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGZpcnN0Rm9jdXNhYmxlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZX0VTQzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5leGl0T25Fc2MpIHtcbiAgICAgICAgICBzdGVwLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICBpZiAodG91ci5vcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICAgIHRvdXIuYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICB0b3VyLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtZWxlbWVudCB7XG4gICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICBtYXgtd2lkdGg6IDQwMHB4O1xuICAgIG9wYWNpdHk6IDA7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MsIHZpc2liaWxpdHkgMC4zcztcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgei1pbmRleDogOTk5OTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLWVsZW1lbnQge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5dOm5vdCguc2hlcGhlcmQtY2VudGVyZWQpIHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50LCAuc2hlcGhlcmQtZWxlbWVudCAqLFxuICAuc2hlcGhlcmQtZWxlbWVudCAqOmFmdGVyLFxuICAuc2hlcGhlcmQtZWxlbWVudCAqOmJlZm9yZSB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1hcnJvdyxcbiAgLnNoZXBoZXJkLWFycm93OjpiZWZvcmUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTZweDtcbiAgICBoZWlnaHQ6IDE2cHg7XG4gICAgei1pbmRleDogLTE7XG4gIH1cblxuICAuc2hlcGhlcmQtYXJyb3c6YmVmb3JlIHtcbiAgICBjb250ZW50OiAnJztcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XG4gICAgYmFja2dyb3VuZDogI2ZmZiAgO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0ndG9wJ10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIGJvdHRvbTogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2JvdHRvbSddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICB0b3A6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdsZWZ0J10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIHJpZ2h0OiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0ncmlnaHQnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgbGVmdDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50LnNoZXBoZXJkLWNlbnRlcmVkID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG5cblxuICAvKipcbiAgKiBBcnJvdyBvbiB0b3Agb2YgdG9vbHRpcCBjZW50ZXJlZCBob3Jpem9udGFsbHksIHdpdGggdGl0bGUgY29sb3JcbiAgKi9cbiAgLnNoZXBoZXJkLWVsZW1lbnQuc2hlcGhlcmQtaGFzLXRpdGxlW2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2JvdHRvbSddID4gLnNoZXBoZXJkLWFycm93OjpiZWZvcmUge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7XG4gIH1cblxuICAuc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtdGFyZ2V0LFxuICAuc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtdGFyZ2V0ICoge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGFyaWEtZGVzY3JpYmVkYnk9eyFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGV4dCkgPyBkZXNjcmlwdGlvbklkIDogbnVsbH1cbiAgYXJpYS1sYWJlbGxlZGJ5PXtzdGVwLm9wdGlvbnMudGl0bGUgPyBsYWJlbElkIDogbnVsbH1cbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzczpzaGVwaGVyZC1oYXMtY2FuY2VsLWljb249XCJ7aGFzQ2FuY2VsSWNvbn1cIlxuICBjbGFzczpzaGVwaGVyZC1oYXMtdGl0bGU9XCJ7aGFzVGl0bGV9XCJcbiAgY2xhc3M6c2hlcGhlcmQtZWxlbWVudD1cInt0cnVlfVwiXG4gIHsuLi5kYXRhU3RlcElkfVxuICBvbjprZXlkb3duPXtoYW5kbGVLZXlEb3dufVxuICByb2xlPVwiZGlhbG9nXCJcbiAgdGFiaW5kZXg9XCIwXCJcbj5cbiAgICB7I2lmIHN0ZXAub3B0aW9ucy5hcnJvdyAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8gJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvLmVsZW1lbnQgJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvLm9ufVxuICAgICAgPGRpdiBjbGFzcz1cInNoZXBoZXJkLWFycm93XCIgZGF0YS1wb3BwZXItYXJyb3c+PC9kaXY+XG4gICAgey9pZn1cbiAgPFNoZXBoZXJkQ29udGVudFxuICAgIHtkZXNjcmlwdGlvbklkfVxuICAgIHtsYWJlbElkfVxuICAgIHtzdGVwfVxuICAvPlxuPC9kaXY+XG4iLCIvKiBzbW9vdGhzY3JvbGwgdjAuNC40IC0gMjAxOSAtIER1c3RhbiBLYXN0ZW4sIEplcmVtaWFzIE1lbmljaGVsbGkgLSBNSVQgTGljZW5zZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIC8vIGFsaWFzZXNcbiAgICB2YXIgdyA9IHdpbmRvdztcbiAgICB2YXIgZCA9IGRvY3VtZW50O1xuXG4gICAgLy8gcmV0dXJuIGlmIHNjcm9sbCBiZWhhdmlvciBpcyBzdXBwb3J0ZWQgYW5kIHBvbHlmaWxsIGlzIG5vdCBmb3JjZWRcbiAgICBpZiAoXG4gICAgICAnc2Nyb2xsQmVoYXZpb3InIGluIGQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmXG4gICAgICB3Ll9fZm9yY2VTbW9vdGhTY3JvbGxQb2x5ZmlsbF9fICE9PSB0cnVlXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2xvYmFsc1xuICAgIHZhciBFbGVtZW50ID0gdy5IVE1MRWxlbWVudCB8fCB3LkVsZW1lbnQ7XG4gICAgdmFyIFNDUk9MTF9USU1FID0gNDY4O1xuXG4gICAgLy8gb2JqZWN0IGdhdGhlcmluZyBvcmlnaW5hbCBzY3JvbGwgbWV0aG9kc1xuICAgIHZhciBvcmlnaW5hbCA9IHtcbiAgICAgIHNjcm9sbDogdy5zY3JvbGwgfHwgdy5zY3JvbGxUbyxcbiAgICAgIHNjcm9sbEJ5OiB3LnNjcm9sbEJ5LFxuICAgICAgZWxlbWVudFNjcm9sbDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIHx8IHNjcm9sbEVsZW1lbnQsXG4gICAgICBzY3JvbGxJbnRvVmlldzogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xuXG4gICAgLy8gZGVmaW5lIHRpbWluZyBtZXRob2RcbiAgICB2YXIgbm93ID1cbiAgICAgIHcucGVyZm9ybWFuY2UgJiYgdy5wZXJmb3JtYW5jZS5ub3dcbiAgICAgICAgPyB3LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHcucGVyZm9ybWFuY2UpXG4gICAgICAgIDogRGF0ZS5ub3c7XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYSB0aGUgY3VycmVudCBicm93c2VyIGlzIG1hZGUgYnkgTWljcm9zb2Z0XG4gICAgICogQG1ldGhvZCBpc01pY3Jvc29mdEJyb3dzZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlckFnZW50XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNaWNyb3NvZnRCcm93c2VyKHVzZXJBZ2VudCkge1xuICAgICAgdmFyIHVzZXJBZ2VudFBhdHRlcm5zID0gWydNU0lFICcsICdUcmlkZW50LycsICdFZGdlLyddO1xuXG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1c2VyQWdlbnRQYXR0ZXJucy5qb2luKCd8JykpLnRlc3QodXNlckFnZW50KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIElFIGhhcyByb3VuZGluZyBidWcgcm91bmRpbmcgZG93biBjbGllbnRIZWlnaHQgYW5kIGNsaWVudFdpZHRoIGFuZFxuICAgICAqIHJvdW5kaW5nIHVwIHNjcm9sbEhlaWdodCBhbmQgc2Nyb2xsV2lkdGggY2F1c2luZyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgKiBvbiBoYXNTY3JvbGxhYmxlU3BhY2VcbiAgICAgKi9cbiAgICB2YXIgUk9VTkRJTkdfVE9MRVJBTkNFID0gaXNNaWNyb3NvZnRCcm93c2VyKHcubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAxIDogMDtcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBzY3JvbGxFbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsRWxlbWVudCh4LCB5KSB7XG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzdWx0IG9mIGFwcGx5aW5nIGVhc2UgbWF0aCBmdW5jdGlvbiB0byBhIG51bWJlclxuICAgICAqIEBtZXRob2QgZWFzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgc21vb3RoIGJlaGF2aW9yIHNob3VsZCBiZSBhcHBsaWVkXG4gICAgICogQG1ldGhvZCBzaG91bGRCYWlsT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBmaXJzdEFyZ1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZEJhaWxPdXQoZmlyc3RBcmcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZmlyc3RBcmcgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIGZpcnN0QXJnICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnYXV0bycgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdpbnN0YW50J1xuICAgICAgKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3QvbnVsbFxuICAgICAgICAvLyBvciBiZWhhdmlvciBpcyBhdXRvLCBpbnN0YW50IG9yIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ29iamVjdCcgJiYgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgYmVoYXZpb3IgaXMgc21vb3RoXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhyb3cgZXJyb3Igd2hlbiBiZWhhdmlvciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnYmVoYXZpb3IgbWVtYmVyIG9mIFNjcm9sbE9wdGlvbnMgJyArXG4gICAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgK1xuICAgICAgICAgICcgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIGVudW1lcmF0aW9uIFNjcm9sbEJlaGF2aW9yLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgc3BhY2UgaW4gdGhlIHByb3ZpZGVkIGF4aXNcbiAgICAgKiBAbWV0aG9kIGhhc1Njcm9sbGFibGVTcGFjZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1Njcm9sbGFibGVTcGFjZShlbCwgYXhpcykge1xuICAgICAgaWYgKGF4aXMgPT09ICdZJykge1xuICAgICAgICByZXR1cm4gZWwuY2xpZW50SGVpZ2h0ICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYXhpcyA9PT0gJ1gnKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGllbnRXaWR0aCArIFJPVU5ESU5HX1RPTEVSQU5DRSA8IGVsLnNjcm9sbFdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhbiBlbGVtZW50IGhhcyBhIHNjcm9sbGFibGUgb3ZlcmZsb3cgcHJvcGVydHkgaW4gdGhlIGF4aXNcbiAgICAgKiBAbWV0aG9kIGNhbk92ZXJmbG93XG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FuT3ZlcmZsb3coZWwsIGF4aXMpIHtcbiAgICAgIHZhciBvdmVyZmxvd1ZhbHVlID0gdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKVsnb3ZlcmZsb3cnICsgYXhpc107XG5cbiAgICAgIHJldHVybiBvdmVyZmxvd1ZhbHVlID09PSAnYXV0bycgfHwgb3ZlcmZsb3dWYWx1ZSA9PT0gJ3Njcm9sbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgY2FuIGJlIHNjcm9sbGVkIGluIGVpdGhlciBheGlzXG4gICAgICogQG1ldGhvZCBpc1Njcm9sbGFibGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Njcm9sbGFibGUoZWwpIHtcbiAgICAgIHZhciBpc1Njcm9sbGFibGVZID0gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCAnWScpICYmIGNhbk92ZXJmbG93KGVsLCAnWScpO1xuICAgICAgdmFyIGlzU2Nyb2xsYWJsZVggPSBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsICdYJykgJiYgY2FuT3ZlcmZsb3coZWwsICdYJyk7XG5cbiAgICAgIHJldHVybiBpc1Njcm9sbGFibGVZIHx8IGlzU2Nyb2xsYWJsZVg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZHMgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2QgZmluZFNjcm9sbGFibGVQYXJlbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge05vZGV9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVQYXJlbnQoZWwpIHtcbiAgICAgIHdoaWxlIChlbCAhPT0gZC5ib2R5ICYmIGlzU2Nyb2xsYWJsZShlbCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZSB8fCBlbC5ob3N0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZiBpbnZva2VkIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAgICAgKiBAbWV0aG9kIHN0ZXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRYO1xuICAgICAgdmFyIGN1cnJlbnRZO1xuICAgICAgdmFyIGVsYXBzZWQgPSAodGltZSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIFNDUk9MTF9USU1FO1xuXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcbiAgICAgIHZhbHVlID0gZWFzZShlbGFwc2VkKTtcblxuICAgICAgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICAgIGN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XG5cbiAgICAgIGNvbnRleHQubWV0aG9kLmNhbGwoY29udGV4dC5zY3JvbGxhYmxlLCBjdXJyZW50WCwgY3VycmVudFkpO1xuXG4gICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgaWYgKGN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY3VycmVudFkgIT09IGNvbnRleHQueSkge1xuICAgICAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwLmJpbmQodywgY29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNjcm9sbHMgd2luZG93IG9yIGVsZW1lbnQgd2l0aCBhIHNtb290aCBiZWhhdmlvclxuICAgICAqIEBtZXRob2Qgc21vb3RoU2Nyb2xsXG4gICAgICogQHBhcmFtIHtPYmplY3R8Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoZWwsIHgsIHkpIHtcbiAgICAgIHZhciBzY3JvbGxhYmxlO1xuICAgICAgdmFyIHN0YXJ0WDtcbiAgICAgIHZhciBzdGFydFk7XG4gICAgICB2YXIgbWV0aG9kO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gICAgICAvLyBkZWZpbmUgc2Nyb2xsIGNvbnRleHRcbiAgICAgIGlmIChlbCA9PT0gZC5ib2R5KSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSB3O1xuICAgICAgICBzdGFydFggPSB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldDtcbiAgICAgICAgc3RhcnRZID0gdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQ7XG4gICAgICAgIG1ldGhvZCA9IG9yaWdpbmFsLnNjcm9sbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSBlbDtcbiAgICAgICAgc3RhcnRYID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgc3RhcnRZID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBtZXRob2QgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBzY3JvbGwgbG9vcGluZyBvdmVyIGEgZnJhbWVcbiAgICAgIHN0ZXAoe1xuICAgICAgICBzY3JvbGxhYmxlOiBzY3JvbGxhYmxlLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT1JJR0lOQUwgTUVUSE9EUyBPVkVSUklERVNcbiAgICAvLyB3LnNjcm9sbCBhbmQgdy5zY3JvbGxUb1xuICAgIHcuc2Nyb2xsID0gdy5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnXG4gICAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICAgIDogdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQsXG4gICAgICAgICAgLy8gdXNlIHRvcCBwcm9wLCBzZWNvbmQgYXJndW1lbnQgaWYgcHJlc2VudCBvciBmYWxsYmFjayB0byBzY3JvbGxZXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMV1cbiAgICAgICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHcsXG4gICAgICAgIGQuYm9keSxcbiAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgIDogdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQsXG4gICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gdy5zY3JvbGxCeVxuICAgIHcuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEJ5LmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnID8gYXJndW1lbnRzWzBdIDogMCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDBcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQgKyAody5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQpLFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3AgKyAody5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgYW5kIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsID0gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGlmIG9uZSBudW1iZXIgaXMgcGFzc2VkLCB0aHJvdyBlcnJvciB0byBtYXRjaCBGaXJlZm94IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVmFsdWUgY291bGQgbm90IGJlIGNvbnZlcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgLy8gdXNlIGxlZnQgcHJvcCwgZmlyc3QgbnVtYmVyIGFyZ3VtZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbExlZnRcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCcgPyB+fmFyZ3VtZW50c1swXSA6IHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAvLyB1c2UgdG9wIHByb3AsIHNlY29uZCBhcmd1bWVudCBvciBmYWxsYmFjayB0byBzY3JvbGxUb3BcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gfn5hcmd1bWVudHNbMV0gOiB0aGlzLnNjcm9sbFRvcFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSBhcmd1bWVudHNbMF0ubGVmdDtcbiAgICAgIHZhciB0b3AgPSBhcmd1bWVudHNbMF0udG9wO1xuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zY3JvbGxMZWZ0IDogfn5sZWZ0LFxuICAgICAgICB0eXBlb2YgdG9wID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2Nyb2xsVG9wIDogfn50b3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLmVsZW1lbnRTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdCArIHRoaXMuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1swXSArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3BcbiAgICAgICAgICAgIDogfn5hcmd1bWVudHNbMV0gKyB0aGlzLnNjcm9sbFRvcFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGwoe1xuICAgICAgICBsZWZ0OiB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICB0b3A6IH5+YXJndW1lbnRzWzBdLnRvcCArIHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICBiZWhhdmlvcjogYXJndW1lbnRzWzBdLmJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGxJbnRvVmlldy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICB2YXIgc2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50KHRoaXMpO1xuICAgICAgdmFyIHBhcmVudFJlY3RzID0gc2Nyb2xsYWJsZVBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjbGllbnRSZWN0cyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChzY3JvbGxhYmxlUGFyZW50ICE9PSBkLmJvZHkpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW5zaWRlIHBhcmVudFxuICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxMZWZ0ICsgY2xpZW50UmVjdHMubGVmdCAtIHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgKyBjbGllbnRSZWN0cy50b3AgLSBwYXJlbnRSZWN0cy50b3BcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZXZlYWwgcGFyZW50IGluIHZpZXdwb3J0IHVubGVzcyBpcyBmaXhlZFxuICAgICAgICBpZiAody5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGFibGVQYXJlbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBwYXJlbnRSZWN0cy50b3AsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgbGVmdDogY2xpZW50UmVjdHMubGVmdCxcbiAgICAgICAgICB0b3A6IGNsaWVudFJlY3RzLnRvcCxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjb21tb25qc1xuICAgIG1vZHVsZS5leHBvcnRzID0geyBwb2x5ZmlsbDogcG9seWZpbGwgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnbG9iYWxcbiAgICBwb2x5ZmlsbCgpO1xuICB9XG5cbn0oKSk7XG4iLCJpbXBvcnQgbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCB7IEV2ZW50ZWQgfSBmcm9tICcuL2V2ZW50ZWQuanMnO1xuaW1wb3J0IGF1dG9CaW5kIGZyb20gJy4vdXRpbHMvYXV0by1iaW5kLmpzJztcbmltcG9ydCB7XG4gIGlzRWxlbWVudCxcbiAgaXNIVE1MRWxlbWVudCxcbiAgaXNGdW5jdGlvbixcbiAgaXNVbmRlZmluZWRcbn0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrLmpzJztcbmltcG9ydCB7IGJpbmRBZHZhbmNlIH0gZnJvbSAnLi91dGlscy9iaW5kLmpzJztcbmltcG9ydCB7XG4gIHNldHVwVG9vbHRpcCxcbiAgcGFyc2VBdHRhY2hUbyxcbiAgbm9ybWFsaXplUHJlZml4LFxuICB1dWlkXG59IGZyb20gJy4vdXRpbHMvZ2VuZXJhbC5qcyc7XG5pbXBvcnQgU2hlcGhlcmRFbGVtZW50IGZyb20gJy4vY29tcG9uZW50cy9zaGVwaGVyZC1lbGVtZW50LnN2ZWx0ZSc7XG5cbi8vIFBvbHlmaWxsc1xuaW1wb3J0IHNtb290aHNjcm9sbCBmcm9tICdzbW9vdGhzY3JvbGwtcG9seWZpbGwnO1xuc21vb3Roc2Nyb2xsLnBvbHlmaWxsKCk7XG5cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgc3RlcHMgdG8gYmUgYWRkZWQgdG8gYSB0b3VyLlxuICogQGV4dGVuZHMge0V2ZW50ZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBTdGVwIGV4dGVuZHMgRXZlbnRlZCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdGVwXG4gICAqIEBwYXJhbSB7VG91cn0gdG91ciBUaGUgdG91ciBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5hcnJvdyBXaGV0aGVyIHRvIGRpc3BsYXkgdGhlIGFycm93IGZvciB0aGUgdG9vbHRpcCBvciBub3QuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuYXR0YWNoVG8gVGhlIGVsZW1lbnQgdGhlIHN0ZXAgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIG9uIHRoZSBwYWdlLlxuICAgKiBBbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGBlbGVtZW50YCBhbmQgYG9uYC5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3Qgc3RlcCA9IG5ldyBTdGVwKHRvdXIsIHtcbiAgICogICBhdHRhY2hUbzogeyBlbGVtZW50OiAnLnNvbWUgLnNlbGVjdG9yLXBhdGgnLCBvbjogJ2xlZnQnIH0sXG4gICAqICAgLi4ubW9yZU9wdGlvbnNcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3UgZG9u4oCZdCBzcGVjaWZ5IGFuIGBhdHRhY2hUb2AgdGhlIGVsZW1lbnQgd2lsbCBhcHBlYXIgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLiBUaGUgc2FtZSB3aWxsIGhhcHBlbiBpZiB5b3VyIGBhdHRhY2hUby5lbGVtZW50YCBjYWxsYmFjayByZXR1cm5zIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yIGEgc2VsZWN0b3IgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgRE9NLlxuICAgKiBJZiB5b3Ugb21pdCB0aGUgYG9uYCBwb3J0aW9uIG9mIGBhdHRhY2hUb2AsIHRoZSBlbGVtZW50IHdpbGwgc3RpbGwgYmUgaGlnaGxpZ2h0ZWQsIGJ1dCB0aGUgdG9vbHRpcCB3aWxsIGFwcGVhclxuICAgKiBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4sIHdpdGhvdXQgYW4gYXJyb3cgcG9pbnRpbmcgdG8gdGhlIHRhcmdldC5cbiAgICogSWYgdGhlIGVsZW1lbnQgdG8gaGlnaGxpZ2h0IGRvZXMgbm90IHlldCBleGlzdCB3aGlsZSBpbnN0YW50aWF0aW5nIHRvdXIgc3RlcHMsIHlvdSBtYXkgdXNlIGxhenkgZXZhbHVhdGlvbiBieSBzdXBwbHlpbmcgYSBmdW5jdGlvbiB0byBgYXR0YWNoVG8uZWxlbWVudGAuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYGJlZm9yZS1zaG93YCBwaGFzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR8ZnVuY3Rpb259IG9wdGlvbnMuYXR0YWNoVG8uZWxlbWVudCBBbiBlbGVtZW50IHNlbGVjdG9yIHN0cmluZywgRE9NIGVsZW1lbnQsIG9yIGEgZnVuY3Rpb24gKHJldHVybmluZyBhIHNlbGVjdG9yLCBhIERPTSBlbGVtZW50LCBgbnVsbGAgb3IgYHVuZGVmaW5lZGApLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hdHRhY2hUby5vbiBUaGUgb3B0aW9uYWwgZGlyZWN0aW9uIHRvIHBsYWNlIHRoZSBQb3BwZXIgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudC5cbiAgICogICAtIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXM6ICdhdXRvJywgJ2F1dG8tc3RhcnQnLCAnYXV0by1lbmQnLCAndG9wJywgJ3RvcC1zdGFydCcsICd0b3AtZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdyaWdodCcsICdyaWdodC1zdGFydCcsICdyaWdodC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0JywgJ2xlZnQtZW5kJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hZHZhbmNlT24gQW4gYWN0aW9uIG9uIHRoZSBwYWdlIHdoaWNoIHNob3VsZCBhZHZhbmNlIHNoZXBoZXJkIHRvIHRoZSBuZXh0IHN0ZXAuXG4gICAqIEl0IHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBhIHN0cmluZyBgc2VsZWN0b3JgIGFuZCBhbiBgZXZlbnRgIG5hbWVcbiAgICogYGBganNcbiAgICogY29uc3Qgc3RlcCA9IG5ldyBTdGVwKHRvdXIsIHtcbiAgICogICBhZHZhbmNlT246IHsgc2VsZWN0b3I6ICcuc29tZSAuc2VsZWN0b3ItcGF0aCcsIGV2ZW50OiAnY2xpY2snIH0sXG4gICAqICAgLi4ubW9yZU9wdGlvbnNcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBgZXZlbnRgIGRvZXNu4oCZdCBoYXZlIHRvIGJlIGFuIGV2ZW50IGluc2lkZSB0aGUgdG91ciwgaXQgY2FuIGJlIGFueSBldmVudCBmaXJlZCBvbiBhbnkgZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAgICogWW91IGNhbiBhbHNvIGFsd2F5cyBtYW51YWxseSBhZHZhbmNlIHRoZSBUb3VyIGJ5IGNhbGxpbmcgYG15VG91ci5uZXh0KClgLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmJlZm9yZVNob3dQcm9taXNlIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICogV2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcywgdGhlIHJlc3Qgb2YgdGhlIGBzaG93YCBjb2RlIGZvciB0aGUgc3RlcCB3aWxsIGV4ZWN1dGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdGlvbnMuYnV0dG9ucyBBbiBhcnJheSBvZiBidXR0b25zIHRvIGFkZCB0byB0aGUgc3RlcC4gVGhlc2Ugd2lsbCBiZSByZW5kZXJlZCBpbiBhXG4gICAqIGZvb3RlciBiZWxvdyB0aGUgbWFpbiBib2R5IHRleHQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uYWN0aW9uIEEgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQgb24uXG4gICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgYm91bmQgdG8gdGhlIGB0b3VyYCB0aGUgc3RlcCBpcyBhc3NvY2lhdGVkIHdpdGgsIHNvIHRoaW5ncyBsaWtlIGB0aGlzLm5leHRgIHdpbGxcbiAgICogd29yayBpbnNpZGUgdGhlIGFjdGlvbi5cbiAgICogWW91IGNhbiB1c2UgYWN0aW9uIHRvIHNraXAgc3RlcHMgb3IgbmF2aWdhdGUgdG8gc3BlY2lmaWMgc3RlcHMsIHdpdGggc29tZXRoaW5nIGxpa2U6XG4gICAqIGBgYGpzXG4gICAqIGFjdGlvbigpIHtcbiAgICogICByZXR1cm4gdGhpcy5zaG93KCdzb21lX3N0ZXBfbmFtZScpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5jbGFzc2VzIEV4dHJhIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIGA8YT5gXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5kaXNhYmxlZCBTaG91bGQgdGhlIGJ1dHRvbiBiZSBkaXNhYmxlZD9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24ubGFiZWwgVGhlIGFyaWEtbGFiZWwgdGV4dCBvZiB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5zZWNvbmRhcnkgSWYgdHJ1ZSwgYSBzaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5IGNsYXNzIGlzIGFwcGxpZWQgdG8gdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi50ZXh0IFRoZSBIVE1MIHRleHQgb2YgdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2FuQ2xpY2tUYXJnZXQgQSBib29sZWFuLCB0aGF0IHdoZW4gc2V0IHRvIGZhbHNlLCB3aWxsIHNldCBgcG9pbnRlci1ldmVudHM6IG5vbmVgIG9uIHRoZSB0YXJnZXRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2FuY2VsSWNvbiBPcHRpb25zIGZvciB0aGUgY2FuY2VsIGljb25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZCBTaG91bGQgYSBjYW5jZWwg4oCc4pyV4oCdIGJlIHNob3duIGluIHRoZSBoZWFkZXIgb2YgdGhlIHN0ZXA/XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhbmNlbEljb24ubGFiZWwgVGhlIGxhYmVsIHRvIGFkZCBmb3IgYGFyaWEtbGFiZWxgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNsYXNzZXMgQSBzdHJpbmcgb2YgZXh0cmEgY2xhc3NlcyB0byBhZGQgdG8gdGhlIHN0ZXAncyBjb250ZW50IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmhpZ2hsaWdodENsYXNzIEFuIGV4dHJhIGNsYXNzIHRvIGFwcGx5IHRvIHRoZSBgYXR0YWNoVG9gIGVsZW1lbnQgd2hlbiBpdCBpc1xuICAgKiBoaWdobGlnaHRlZCAodGhhdCBpcywgd2hlbiBpdHMgc3RlcCBpcyBhY3RpdmUpLiBZb3UgY2FuIHRoZW4gdGFyZ2V0IHRoYXQgc2VsZWN0b3IgaW4geW91ciBDU1MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmlkIFRoZSBzdHJpbmcgdG8gdXNlIGFzIHRoZSBgaWRgIGZvciB0aGUgc3RlcC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgQW4gYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgQW4gYW1vdW50IG9mIGJvcmRlciByYWRpdXMgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnBvcHBlck9wdGlvbnMgRXh0cmEgb3B0aW9ucyB0byBwYXNzIHRvIFBvcHBlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBvcHRpb25zLnNjcm9sbFRvIFNob3VsZCB0aGUgZWxlbWVudCBiZSBzY3JvbGxlZCB0byB3aGVuIHRoaXMgc3RlcCBpcyBzaG93bj8gSWYgdHJ1ZSwgdXNlcyB0aGUgZGVmYXVsdCBgc2Nyb2xsSW50b1ZpZXdgLFxuICAgKiBpZiBhbiBvYmplY3QsIHBhc3NlcyB0aGF0IG9iamVjdCBhcyB0aGUgcGFyYW1zIHRvIGBzY3JvbGxJbnRvVmlld2AgaS5lLiBge2JlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdjZW50ZXInfWBcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IGxldHMgeW91IG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNjcm9sbFRvIGJlaGF2aW9yIGFuZFxuICAgKiBkZWZpbmUgYSBjdXN0b20gYWN0aW9uIHRvIGRvIHRoZSBzY3JvbGxpbmcsIGFuZCBwb3NzaWJseSBvdGhlciBsb2dpYy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zaG93T24gQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGl0IHJldHVybnMgYHRydWVgLCB3aWxsIHNob3cgdGhlIHN0ZXAuXG4gICAqIElmIGl0IHJldHVybnMgZmFsc2UsIHRoZSBzdGVwIHdpbGwgYmUgc2tpcHBlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGV4dCBUaGUgdGV4dCBpbiB0aGUgYm9keSBvZiB0aGUgc3RlcC4gSXQgY2FuIGJlIG9uZSBvZiB0aHJlZSB0eXBlczpcbiAgICogYGBgXG4gICAqIC0gSFRNTCBzdHJpbmdcbiAgICogLSBgSFRNTEVsZW1lbnRgIG9iamVjdFxuICAgKiAtIGBGdW5jdGlvbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgc3RlcCBpcyBidWlsdC4gSXQgbXVzdCByZXR1cm4gb25lIHRoZSB0d28gb3B0aW9ucyBhYm92ZS5cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIFRoZSBzdGVwJ3MgdGl0bGUuIEl0IGJlY29tZXMgYW4gYGgzYCBhdCB0aGUgdG9wIG9mIHRoZSBzdGVwLiBJdCBjYW4gYmUgb25lIG9mIHR3byB0eXBlczpcbiAgICogYGBgXG4gICAqIC0gSFRNTCBzdHJpbmdcbiAgICogLSBgRnVuY3Rpb25gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHN0ZXAgaXMgYnVpbHQuIEl0IG11c3QgcmV0dXJuIEhUTUwgc3RyaW5nLlxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMud2hlbiBZb3UgY2FuIGRlZmluZSBgc2hvd2AsIGBoaWRlYCwgZXRjIGV2ZW50cyBpbnNpZGUgYHdoZW5gLiBGb3IgZXhhbXBsZTpcbiAgICogYGBganNcbiAgICogd2hlbjoge1xuICAgKiAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7U3RlcH0gVGhlIG5ld2x5IGNyZWF0ZWQgU3RlcCBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IodG91ciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodG91ciwgb3B0aW9ucyk7XG4gICAgdGhpcy50b3VyID0gdG91cjtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gdGhpcy50b3VyLm9wdGlvbnNcbiAgICAgID8gbm9ybWFsaXplUHJlZml4KHRoaXMudG91ci5vcHRpb25zLmNsYXNzUHJlZml4KVxuICAgICAgOiAnJztcbiAgICB0aGlzLnN0eWxlcyA9IHRvdXIuc3R5bGVzO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgYXR0YWNoVG8gb3B0aW9ucy4gRHVlIHRvIGxhenkgZXZhbHVhdGlvbiwgd2Ugb25seSByZXNvbHZlIHRoZSBvcHRpb25zIGR1cmluZyBgYmVmb3JlLXNob3dgIHBoYXNlLlxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBkaXJlY3RseSwgdXNlIHRoZSBfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMgbWV0aG9kIGluc3RlYWQuXG4gICAgICogQHR5cGUge251bGx8e318e2VsZW1lbnQsIHRvfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG8gPSBudWxsO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHRoZSB0b3VyXG4gICAqIFRyaWdnZXJzIHRoZSBgY2FuY2VsYCBldmVudFxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMudG91ci5jYW5jZWwoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIHRoZSB0b3VyXG4gICAqIFRyaWdnZXJzIHRoZSBgY29tcGxldGVgIGV2ZW50XG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLnRvdXIuY29tcGxldGUoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBzdGVwLCBkZWxldGUgdGhlIHN0ZXAncyBlbGVtZW50LCBhbmQgZGVzdHJveSB0aGUgUG9wcGVyIGluc3RhbmNlIGZvciB0aGUgc3RlcC5cbiAgICogVHJpZ2dlcnMgYGRlc3Ryb3lgIGV2ZW50XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRvb2x0aXApIHtcbiAgICAgIHRoaXMudG9vbHRpcC5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRoaXMuZWwpICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG91ciBmb3IgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7VG91cn0gVGhlIHRvdXIgaW5zdGFuY2VcbiAgICovXG4gIGdldFRvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudG91cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBzdGVwXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMudG91ci5tb2RhbC5oaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZS1oaWRlJyk7XG5cbiAgICBpZiAodGhpcy5lbCkge1xuICAgICAgdGhpcy5lbC5oaWRkZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignaGlkZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGF0dGFjaFRvIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMoKSB7XG4gICAgdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbyA9IHBhcnNlQXR0YWNoVG8odGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG87XG4gIH1cblxuICAvKipcbiAgICogQSBzZWxlY3RvciBmb3IgcmVzb2x2ZWQgYXR0YWNoVG8gb3B0aW9ucy5cbiAgICogQHJldHVybnMge3t9fHtlbGVtZW50LCBvbn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuX3Jlc29sdmVkQXR0YWNoVG8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG87XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHN0ZXAgaXMgb3BlbiBhbmQgdmlzaWJsZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdGVwIGlzIG9wZW4gYW5kIHZpc2libGVcbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmVsICYmICF0aGlzLmVsLmhpZGRlbik7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYF9zaG93YCBhbmQgZW5zdXJlcyBgYmVmb3JlU2hvd1Byb21pc2VgIHJlc29sdmVzIGJlZm9yZSBjYWxsaW5nIHNob3dcbiAgICogQHJldHVybiB7KnxQcm9taXNlfVxuICAgKi9cbiAgc2hvdygpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UpKSB7XG4gICAgICBjb25zdCBiZWZvcmVTaG93UHJvbWlzZSA9IHRoaXMub3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSgpO1xuICAgICAgaWYgKCFpc1VuZGVmaW5lZChiZWZvcmVTaG93UHJvbWlzZSkpIHtcbiAgICAgICAgcmV0dXJuIGJlZm9yZVNob3dQcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5fc2hvdygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG9wdGlvbnMgb2YgdGhlIHN0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKi9cbiAgdXBkYXRlU3RlcE9wdGlvbnMob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudCkge1xuICAgICAgdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuJHNldCh7IHN0ZXA6IHRoaXMgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkfSBUaGUgZWxlbWVudCBpbnN0YW5jZS4gdW5kZWZpbmVkIGlmIGl0IGhhcyBuZXZlciBiZWVuIHNob3duLCBudWxsIGlmIGl0IGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YXJnZXQgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkfSBUaGUgZWxlbWVudCBpbnN0YW5jZS4gdW5kZWZpbmVkIGlmIGl0IGhhcyBuZXZlciBiZWVuIHNob3duLCBudWxsIGlmIHF1ZXJ5IHN0cmluZyBoYXMgbm90IGJlZW4gZm91bmRcbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBTaGVwaGVyZCBlbGVtZW50IGZvciBzdGVwIGJhc2VkIG9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIERPTSBlbGVtZW50IGZvciB0aGUgc3RlcCB0b29sdGlwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlVG9vbHRpcENvbnRlbnQoKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb25JZCA9IGAke3RoaXMuaWR9LWRlc2NyaXB0aW9uYDtcbiAgICBjb25zdCBsYWJlbElkID0gYCR7dGhpcy5pZH0tbGFiZWxgO1xuXG4gICAgdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQgPSBuZXcgU2hlcGhlcmRFbGVtZW50KHtcbiAgICAgIHRhcmdldDogdGhpcy50b3VyLm9wdGlvbnMuc3RlcHNDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsYXNzUHJlZml4OiB0aGlzLmNsYXNzUHJlZml4LFxuICAgICAgICBkZXNjcmlwdGlvbklkLFxuICAgICAgICBsYWJlbElkLFxuICAgICAgICBzdGVwOiB0aGlzLFxuICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgY3VzdG9tIHNjcm9sbFRvSGFuZGxlciBpcyBkZWZpbmVkLCBjYWxsIHRoYXQsIG90aGVyd2lzZSBkbyB0aGUgZ2VuZXJpY1xuICAgKiBzY3JvbGxJbnRvVmlldyBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBzY3JvbGxUb09wdGlvbnMgSWYgdHJ1ZSwgdXNlcyB0aGUgZGVmYXVsdCBgc2Nyb2xsSW50b1ZpZXdgLFxuICAgKiBpZiBhbiBvYmplY3QsIHBhc3NlcyB0aGF0IG9iamVjdCBhcyB0aGUgcGFyYW1zIHRvIGBzY3JvbGxJbnRvVmlld2AgaS5lLiBgeyBiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnY2VudGVyJyB9YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Njcm9sbFRvKHNjcm9sbFRvT3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcy5fZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyKGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpc0VsZW1lbnQoZWxlbWVudCkgJiZcbiAgICAgIHR5cGVvZiBlbGVtZW50LnNjcm9sbEludG9WaWV3ID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KHNjcm9sbFRvT3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIF9nZXRDbGFzc09wdGlvbnMgZ2V0cyBhbGwgcG9zc2libGUgY2xhc3NlcyBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0ZXBPcHRpb25zIFRoZSBzdGVwIHNwZWNpZmljIG9wdGlvbnNcbiAgICogQHJldHVybnMge1N0cmluZ30gdW5pcXVlIHN0cmluZyBmcm9tIGFycmF5IG9mIGNsYXNzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDbGFzc09wdGlvbnMoc3RlcE9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnMgPVxuICAgICAgdGhpcy50b3VyICYmIHRoaXMudG91ci5vcHRpb25zICYmIHRoaXMudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcbiAgICBjb25zdCBzdGVwQ2xhc3NlcyA9IHN0ZXBPcHRpb25zLmNsYXNzZXMgPyBzdGVwT3B0aW9ucy5jbGFzc2VzIDogJyc7XG4gICAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3NlcyA9XG4gICAgICBkZWZhdWx0U3RlcE9wdGlvbnMgJiYgZGVmYXVsdFN0ZXBPcHRpb25zLmNsYXNzZXNcbiAgICAgICAgPyBkZWZhdWx0U3RlcE9wdGlvbnMuY2xhc3Nlc1xuICAgICAgICA6ICcnO1xuICAgIGNvbnN0IGFsbENsYXNzZXMgPSBbXG4gICAgICAuLi5zdGVwQ2xhc3Nlcy5zcGxpdCgnICcpLFxuICAgICAgLi4uZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3Nlcy5zcGxpdCgnICcpXG4gICAgXTtcbiAgICBjb25zdCB1bmlxQ2xhc3NlcyA9IG5ldyBTZXQoYWxsQ2xhc3Nlcyk7XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxQ2xhc3Nlcykuam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgc3RlcCwgbWFwcyBgd2hlbmAgdG8gZXZlbnRzLCBzZXRzIHVwIGJ1dHRvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0T3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgdG91ck9wdGlvbnMgPVxuICAgICAgdGhpcy50b3VyICYmIHRoaXMudG91ci5vcHRpb25zICYmIHRoaXMudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcblxuICAgIHRvdXJPcHRpb25zID0gbWVyZ2Uoe30sIHRvdXJPcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGFycm93OiB0cnVlXG4gICAgICB9LFxuICAgICAgdG91ck9wdGlvbnMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGNvbnN0IHsgd2hlbiB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGhpcy5vcHRpb25zLmNsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc09wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkIHx8IGBzdGVwLSR7dXVpZCgpfWA7XG5cbiAgICBpZiAod2hlbikge1xuICAgICAgT2JqZWN0LmtleXMod2hlbikuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5vbihldmVudCwgd2hlbltldmVudF0sIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZWxlbWVudCBhbmQgc2V0IHVwIHRoZSBQb3BwZXIgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cEVsZW1lbnRzKCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5lbCkpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuZWwgPSB0aGlzLl9jcmVhdGVUb29sdGlwQ29udGVudCgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hZHZhbmNlT24pIHtcbiAgICAgIGJpbmRBZHZhbmNlKHRoaXMpO1xuICAgIH1cbiAgICBzZXR1cFRvb2x0aXAodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYGJlZm9yZS1zaG93YCwgZ2VuZXJhdGVzIHRoZSB0b29sdGlwIERPTSBjb250ZW50LFxuICAgKiBzZXRzIHVwIGEgUG9wcGVyIGluc3RhbmNlIGZvciB0aGUgdG9vbHRpcCwgdGhlbiB0cmlnZ2VycyBgc2hvd2AuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2hvdygpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZS1zaG93Jyk7XG5cbiAgICAvLyBGb3JjZSByZXNvbHZlIHRvIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucyBhcmUgdXBkYXRlZCBvbiBzdWJzZXF1ZW50IHNob3dzLlxuICAgIHRoaXMuX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMoKTtcbiAgICB0aGlzLl9zZXR1cEVsZW1lbnRzKCk7XG5cbiAgICBpZiAoIXRoaXMudG91ci5tb2RhbCkge1xuICAgICAgdGhpcy50b3VyLl9zZXR1cE1vZGFsKCk7XG4gICAgfVxuXG4gICAgdGhpcy50b3VyLm1vZGFsLnNldHVwRm9yU3RlcCh0aGlzKTtcbiAgICB0aGlzLl9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwKHRoaXMpO1xuICAgIHRoaXMuZWwuaGlkZGVuID0gZmFsc2U7XG5cbiAgICAvLyBzdGFydCBzY3JvbGxpbmcgdG8gdGFyZ2V0IGJlZm9yZSBzaG93aW5nIHRoZSBzdGVwXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUbykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMub3B0aW9ucy5zY3JvbGxUbyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtZW5hYmxlZGApO1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtdGFyZ2V0YCk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC1lbmFibGVkJyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3Nob3cnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGF0ZXMgdGhlIHN0eWxlcyBvZiB0aGUgcGFzc2VkIHN0ZXAncyB0YXJnZXQgZWxlbWVudCwgYmFzZWQgb24gdGhlIHN0ZXAncyBvcHRpb25zIGFuZFxuICAgKiB0aGUgdG91cidzIGBtb2RhbGAgb3B0aW9uLCB0byB2aXN1YWxseSBlbXBoYXNpemUgdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHN0ZXAgVGhlIHN0ZXAgb2JqZWN0IHRoYXQgYXR0YWNoZXMgdG8gdGhlIGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwKHN0ZXApIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gc3RlcC50YXJnZXQ7XG5cbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5vcHRpb25zLmhpZ2hsaWdodENsYXNzKSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoc3RlcC5vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcpO1xuXG4gICAgaWYgKHN0ZXAub3B0aW9ucy5jYW5DbGlja1RhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBzdGVwIGlzIGhpZGRlbiwgcmVtb3ZlIHRoZSBoaWdobGlnaHRDbGFzcyBhbmQgJ3NoZXBoZXJkLWVuYWJsZWQnXG4gICAqIGFuZCAnc2hlcGhlcmQtdGFyZ2V0JyBjbGFzc2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHRDbGFzcykge1xuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnLFxuICAgICAgYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC1lbmFibGVkYCxcbiAgICAgIGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtdGFyZ2V0YFxuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ2xlYW51cCB0aGUgc3RlcHMgYW5kIHNldCBwb2ludGVyRXZlbnRzIGJhY2sgdG8gJ2F1dG8nXG4gKiBAcGFyYW0gdG91ciBUaGUgdG91ciBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBTdGVwcyh0b3VyKSB7XG4gIGlmICh0b3VyKSB7XG4gICAgY29uc3QgeyBzdGVwcyB9ID0gdG91cjtcblxuICAgIHN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgc3RlcC5vcHRpb25zICYmXG4gICAgICAgIHN0ZXAub3B0aW9ucy5jYW5DbGlja1RhcmdldCA9PT0gZmFsc2UgJiZcbiAgICAgICAgc3RlcC5vcHRpb25zLmF0dGFjaFRvXG4gICAgICApIHtcbiAgICAgICAgaWYgKHN0ZXAudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBzdGVwLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEdlbmVyYXRlcyB0aGUgc3ZnIHBhdGggZGF0YSBmb3IgYSByb3VuZGVkIHJlY3RhbmdsZSBvdmVybGF5XG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9uIC0gRGltZW5zaW9ucyBvZiByZWN0YW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBPZmZzZXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIgaW4geCBheGlzLiBkZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBPZmZzZXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIgaW4geSBheGlzLiBkZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3I9MF0gLSBDb3JuZXIgUmFkaXVzLiBLZWVwIHRoaXMgc21hbGxlciB0aGFuICBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUm91bmRlZCByZWN0YW5nbGUgb3ZlcmxheSBwYXRoIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT3ZlcmxheVBhdGgoeyB3aWR0aCwgaGVpZ2h0LCB4ID0gMCwgeSA9IDAsIHIgPSAwIH0pIHtcbiAgY29uc3QgeyBpbm5lcldpZHRoOiB3LCBpbm5lckhlaWdodDogaCB9ID0gd2luZG93O1xuXG4gIHJldHVybiBgTSR7d30sJHtofVxcXG5IMFxcXG5WMFxcXG5IJHt3fVxcXG5WJHtofVxcXG5aXFxcbk0ke3ggKyByfSwke3l9XFxcbmEke3J9LCR7cn0sMCwwLDAtJHtyfSwke3J9XFxcblYke2hlaWdodCArIHkgLSByfVxcXG5hJHtyfSwke3J9LDAsMCwwLCR7cn0sJHtyfVxcXG5IJHt3aWR0aCArIHggLSByfVxcXG5hJHtyfSwke3J9LDAsMCwwLCR7cn0tJHtyfVxcXG5WJHt5ICsgcn1cXFxuYSR7cn0sJHtyfSwwLDAsMC0ke3J9LSR7cn1cXFxuWmA7XG59XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyB1dWlkIH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhbC5qcyc7XG4gIGltcG9ydCB7IG1ha2VPdmVybGF5UGF0aCB9IGZyb20gJy4uL3V0aWxzL292ZXJsYXktcGF0aC5qcyc7XG5cbiAgZXhwb3J0IGxldCBlbGVtZW50LCBvcGVuaW5nUHJvcGVydGllcztcbiAgY29uc3QgZ3VpZCA9IHV1aWQoKTtcbiAgbGV0IG1vZGFsSXNWaXNpYmxlID0gZmFsc2U7XG4gIGxldCByYWZJZCA9IHVuZGVmaW5lZDtcbiAgbGV0IHBhdGhEZWZpbml0aW9uO1xuXG4gICQ6IHBhdGhEZWZpbml0aW9uID0gbWFrZU92ZXJsYXlQYXRoKG9wZW5pbmdQcm9wZXJ0aWVzKTtcblxuICBjbG9zZU1vZGFsT3BlbmluZygpO1xuXG4gIGV4cG9ydCBjb25zdCBnZXRFbGVtZW50ID0gKCkgPT4gZWxlbWVudDtcblxuICBleHBvcnQgZnVuY3Rpb24gY2xvc2VNb2RhbE9wZW5pbmcoKSB7XG4gICAgb3BlbmluZ1Byb3BlcnRpZXMgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgcjogMFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgbW9kYWwgb3ZlcmxheVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgbW9kYWxJc1Zpc2libGUgPSBmYWxzZTtcblxuICAgIC8vIEVuc3VyZSB3ZSBjbGVhbnVwIGFsbCBldmVudCBsaXN0ZW5lcnMgd2hlbiB3ZSBoaWRlIHRoZSBtb2RhbFxuICAgIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50IHdlIHdhbnQgdGhlIG9wZW5pbmcgb3ZlcnRvcCBvZiB0byBzZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9wZW5pbmcgYW5kIHBvc2l0aW9uIGl0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyBBbiBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgQW4gYW1vdW50IG9mIGJvcmRlciByYWRpdXMgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNjcm9sbFBhcmVudCBUaGUgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldEVsZW1lbnQgVGhlIGVsZW1lbnQgdGhlIG9wZW5pbmcgd2lsbCBleHBvc2VcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBwb3NpdGlvbk1vZGFsKFxuICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nID0gMCxcbiAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzID0gMCxcbiAgICBzY3JvbGxQYXJlbnQsXG4gICAgdGFyZ2V0RWxlbWVudFxuICApIHtcbiAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgY29uc3QgeyB5LCBoZWlnaHQgfSA9IF9nZXRWaXNpYmxlSGVpZ2h0KHRhcmdldEVsZW1lbnQsIHNjcm9sbFBhcmVudCk7XG4gICAgICBjb25zdCB7IHgsIHdpZHRoLCBsZWZ0IH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgbm90IGNvbnNpc3RlbnQuIFNvbWUgYnJvd3NlcnMgdXNlIHggYW5kIHksIHdoaWxlIG90aGVycyB1c2UgbGVmdCBhbmQgdG9wXG4gICAgICBvcGVuaW5nUHJvcGVydGllcyA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgKiAyLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nICogMixcbiAgICAgICAgeDogKHggfHwgbGVmdCkgLSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgICAgeTogeSAtIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICByOiBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZU1vZGFsT3BlbmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBtb2RhbCBpcyBlbmFibGVkLCBzZXR1cCB0aGUgc3ZnIG1hc2sgb3BlbmluZyBhbmQgbW9kYWwgb3ZlcmxheSBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gc2V0dXBGb3JTdGVwKHN0ZXApIHtcbiAgICAvLyBFbnN1cmUgd2UgbW92ZSBsaXN0ZW5lcnMgZnJvbSB0aGUgcHJldmlvdXMgc3RlcCwgYmVmb3JlIHdlIHNldHVwIG5ldyBvbmVzXG4gICAgX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChzdGVwLnRvdXIub3B0aW9ucy51c2VNb2RhbE92ZXJsYXkpIHtcbiAgICAgIF9zdHlsZUZvclN0ZXAoc3RlcCk7XG4gICAgICBzaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgbW9kYWwgb3ZlcmxheVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgbW9kYWxJc1Zpc2libGUgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIGNvbnN0IF9wcmV2ZW50TW9kYWxPdmVybGF5VG91Y2ggPSAoZSkgPT4ge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgLy8gUHJldmVudHMgd2luZG93IGZyb20gbW92aW5nIG9uIHRvdWNoLlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfcHJldmVudE1vZGFsQm9keVRvdWNoLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AgYW5kIHJlbW92ZSB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAocmFmSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICAgIHJhZklkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfcHJldmVudE1vZGFsQm9keVRvdWNoLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlIHRoZSBtb2RhbCBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIHRvIHN0eWxlIHRoZSBvcGVuaW5nIGZvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3N0eWxlRm9yU3RlcChzdGVwKSB7XG4gICAgY29uc3Qge1xuICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzXG4gICAgfSA9IHN0ZXAub3B0aW9ucztcblxuICAgIGNvbnN0IHNjcm9sbFBhcmVudCA9IF9nZXRTY3JvbGxQYXJlbnQoc3RlcC50YXJnZXQpO1xuXG4gICAgLy8gU2V0dXAgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNhbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIHVwZGF0ZSB0aGUgbW9kYWwgb3BlbmluZyBwb3NpdGlvblxuICAgIGNvbnN0IHJhZkxvb3AgPSAoKSA9PiB7XG4gICAgICByYWZJZCA9IHVuZGVmaW5lZDtcbiAgICAgIHBvc2l0aW9uTW9kYWwoXG4gICAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzLFxuICAgICAgICBzY3JvbGxQYXJlbnQsXG4gICAgICAgIHN0ZXAudGFyZ2V0XG4gICAgICApO1xuICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmTG9vcCk7XG4gICAgfTtcblxuICAgIHJhZkxvb3AoKTtcblxuICAgIF9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBpc0h0bWxFbGVtZW50ID0gZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIGNvbnN0IG92ZXJmbG93WSA9XG4gICAgICBpc0h0bWxFbGVtZW50ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLm92ZXJmbG93WTtcbiAgICBjb25zdCBpc1Njcm9sbGFibGUgPSBvdmVyZmxvd1kgIT09ICdoaWRkZW4nICYmIG92ZXJmbG93WSAhPT0gJ3Zpc2libGUnO1xuXG4gICAgaWYgKGlzU2Nyb2xsYWJsZSAmJiBlbGVtZW50LnNjcm9sbEhlaWdodCA+PSBlbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRTY3JvbGxQYXJlbnQoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpc2libGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgc2Nyb2xsUGFyZW50LlxuICAgKiBJZiB0aGVyZSBpcyBubyBzY3JvbGwgcGFyZW50LCB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbc2Nyb2xsUGFyZW50XSBUaGUgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7e3k6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFZpc2libGVIZWlnaHQoZWxlbWVudCwgc2Nyb2xsUGFyZW50KSB7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB0b3AgPSBlbGVtZW50UmVjdC55IHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICBsZXQgYm90dG9tID0gZWxlbWVudFJlY3QuYm90dG9tIHx8IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodDtcblxuICAgIGlmIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIGNvbnN0IHNjcm9sbFJlY3QgPSBzY3JvbGxQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxSZWN0LnkgfHwgc2Nyb2xsUmVjdC50b3A7XG4gICAgICBjb25zdCBzY3JvbGxCb3R0b20gPSBzY3JvbGxSZWN0LmJvdHRvbSB8fCBzY3JvbGxUb3AgKyBzY3JvbGxSZWN0LmhlaWdodDtcblxuICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBzY3JvbGxUb3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBzY3JvbGxCb3R0b20pO1xuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KGJvdHRvbSAtIHRvcCwgMCk7IC8vIERlZmF1bHQgdG8gMCBpZiBoZWlnaHQgaXMgbmVnYXRpdmVcblxuICAgIHJldHVybiB7IHk6IHRvcCwgaGVpZ2h0IH07XG4gIH1cbjwvc2NyaXB0PlxuXG48c3ZnXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M9e2Ake1xuICAgIG1vZGFsSXNWaXNpYmxlID8gJ3NoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUnIDogJydcbiAgfSBzaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lcmB9XG4gIG9uOnRvdWNobW92ZT17X3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaH1cbj5cbiAgPHBhdGggZD17cGF0aERlZmluaXRpb259IC8+XG48L3N2Zz5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyIHtcbiAgICBoZWlnaHQ6IDA7XG4gICAgbGVmdDogMDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlLW91dCwgaGVpZ2h0IDBtcyAwLjNzLCBvcGFjaXR5IDAuM3MgMG1zO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICB6LWluZGV4OiA5OTk3O1xuICB9XG5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyLnNoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUge1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgb3BhY2l0eTogMC41O1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2Utb3V0LCBoZWlnaHQgMHMgMHMsIG9wYWNpdHkgMC4zcyAwcztcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gIH1cblxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIuc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZSBwYXRoIHtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICB9XG48L3N0eWxlPlxuIiwiaW1wb3J0IHsgRXZlbnRlZCB9IGZyb20gJy4vZXZlbnRlZC5qcyc7XG5pbXBvcnQgeyBTdGVwIH0gZnJvbSAnLi9zdGVwLmpzJztcbmltcG9ydCBhdXRvQmluZCBmcm9tICcuL3V0aWxzL2F1dG8tYmluZC5qcyc7XG5pbXBvcnQge1xuICBpc0hUTUxFbGVtZW50LFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmluZyxcbiAgaXNVbmRlZmluZWRcbn0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrLmpzJztcbmltcG9ydCB7IGNsZWFudXBTdGVwcyB9IGZyb20gJy4vdXRpbHMvY2xlYW51cC5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVQcmVmaXgsIHV1aWQgfSBmcm9tICcuL3V0aWxzL2dlbmVyYWwuanMnO1xuaW1wb3J0IFNoZXBoZXJkTW9kYWwgZnJvbSAnLi9jb21wb25lbnRzL3NoZXBoZXJkLW1vZGFsLnN2ZWx0ZSc7XG5cbmNvbnN0IFNoZXBoZXJkID0gbmV3IEV2ZW50ZWQoKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgdGhlIHNpdGUgdG91clxuICogQGV4dGVuZHMge0V2ZW50ZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBUb3VyIGV4dGVuZHMgRXZlbnRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHRvdXJcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNvbmZpcm1DYW5jZWwgSWYgdHJ1ZSwgd2lsbCBpc3N1ZSBhIGB3aW5kb3cuY29uZmlybWAgYmVmb3JlIGNhbmNlbGxpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29uZmlybUNhbmNlbE1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpbiB0aGUgY29uZmlybSBkaWFsb2dcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xhc3NQcmVmaXggVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGBzaGVwaGVyZC1lbmFibGVkYCBhbmQgYHNoZXBoZXJkLXRhcmdldGAgY2xhc3MgbmFtZXMgYXMgd2VsbCBhcyB0aGUgYGRhdGEtc2hlcGhlcmQtc3RlcC1pZGAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucyBEZWZhdWx0IG9wdGlvbnMgZm9yIFN0ZXBzICh7QGxpbmsgU3RlcCNjb25zdHJ1Y3Rvcn0pLCBjcmVhdGVkIHRocm91Z2ggYGFkZFN0ZXBgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5leGl0T25Fc2MgRXhpdGluZyB0aGUgdG91ciB3aXRoIHRoZSBlc2NhcGUga2V5IHdpbGwgYmUgZW5hYmxlZCB1bmxlc3MgdGhpcyBpcyBleHBsaWNpdGx5XG4gICAqIHNldCB0byBmYWxzZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbiBOYXZpZ2F0aW5nIHRoZSB0b3VyIHZpYSBsZWZ0IGFuZCByaWdodCBhcnJvdyBrZXlzIHdpbGwgYmUgZW5hYmxlZFxuICAgKiB1bmxlc3MgdGhpcyBpcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5zdGVwc0NvbnRhaW5lciBBbiBvcHRpb25hbCBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIHN0ZXBzLlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgc3RlcHMgd2lsbCBiZSBhcHBlbmRlZCB0byBgZG9jdW1lbnQuYm9keWAuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMubW9kYWxDb250YWluZXIgQW4gb3B0aW9uYWwgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBtb2RhbC5cbiAgICogSWYgbm90IHNldCwgdGhlIG1vZGFsIHdpbGwgYmUgYXBwZW5kZWQgdG8gYGRvY3VtZW50LmJvZHlgLlxuICAgKiBAcGFyYW0ge29iamVjdFtdIHwgU3RlcFtdfSBvcHRpb25zLnN0ZXBzIEFuIGFycmF5IG9mIHN0ZXAgb3B0aW9ucyBvYmplY3RzIG9yIFN0ZXAgaW5zdGFuY2VzIHRvIGluaXRpYWxpemUgdGhlIHRvdXIgd2l0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b3VyTmFtZSBBbiBvcHRpb25hbCBcIm5hbWVcIiBmb3IgdGhlIHRvdXIuIFRoaXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgdGhlIHRvdXInc1xuICAgKiBkeW5hbWljYWxseSBnZW5lcmF0ZWQgYGlkYCBwcm9wZXJ0eSAtLSB3aGljaCBpcyBhbHNvIHNldCBvbiB0aGUgYGJvZHlgIGVsZW1lbnQgYXMgdGhlIGBkYXRhLXNoZXBoZXJkLWFjdGl2ZS10b3VyYCBhdHRyaWJ1dGVcbiAgICogd2hlbmV2ZXIgdGhlIHRvdXIgYmVjb21lcyBhY3RpdmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy51c2VNb2RhbE92ZXJsYXkgV2hldGhlciBvciBub3Qgc3RlcHMgc2hvdWxkIGJlIHBsYWNlZCBhYm92ZSBhIGRhcmtlbmVkXG4gICAqIG1vZGFsIG92ZXJsYXkuIElmIHRydWUsIHRoZSBvdmVybGF5IHdpbGwgY3JlYXRlIGFuIG9wZW5pbmcgYXJvdW5kIHRoZSB0YXJnZXQgZWxlbWVudCBzbyB0aGF0IGl0XG4gICAqIGNhbiByZW1haW4gaW50ZXJhY3RpdmVcbiAgICogQHJldHVybnMge1RvdXJ9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIGF1dG9CaW5kKHRoaXMpO1xuXG4gICAgY29uc3QgZGVmYXVsdFRvdXJPcHRpb25zID0ge1xuICAgICAgZXhpdE9uRXNjOiB0cnVlLFxuICAgICAga2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlXG4gICAgfTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRUb3VyT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5jbGFzc1ByZWZpeCA9IG5vcm1hbGl6ZVByZWZpeCh0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXgpO1xuICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICB0aGlzLmFkZFN0ZXBzKHRoaXMub3B0aW9ucy5zdGVwcyk7XG5cbiAgICAvLyBQYXNzIHRoZXNlIGV2ZW50cyBvbnRvIHRoZSBnbG9iYWwgU2hlcGhlcmQgb2JqZWN0XG4gICAgY29uc3QgZXZlbnRzID0gW1xuICAgICAgJ2FjdGl2ZScsXG4gICAgICAnY2FuY2VsJyxcbiAgICAgICdjb21wbGV0ZScsXG4gICAgICAnaW5hY3RpdmUnLFxuICAgICAgJ3Nob3cnLFxuICAgICAgJ3N0YXJ0J1xuICAgIF07XG4gICAgZXZlbnRzLm1hcCgoZXZlbnQpID0+IHtcbiAgICAgICgoZSkgPT4ge1xuICAgICAgICB0aGlzLm9uKGUsIChvcHRzKSA9PiB7XG4gICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgb3B0cy50b3VyID0gdGhpcztcbiAgICAgICAgICBTaGVwaGVyZC50cmlnZ2VyKGUsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3NldFRvdXJJRCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBzdGVwIHRvIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0ZXB9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc3RlcCBvcHRpb25zIG9yIGEgU3RlcCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIG9wdGlvbmFsIGluZGV4IHRvIGluc2VydCB0aGUgc3RlcCBhdC4gSWYgdW5kZWZpbmVkLCB0aGUgc3RlcFxuICAgKiBpcyBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICogQHJldHVybiB7U3RlcH0gVGhlIG5ld2x5IGFkZGVkIHN0ZXBcbiAgICovXG4gIGFkZFN0ZXAob3B0aW9ucywgaW5kZXgpIHtcbiAgICBsZXQgc3RlcCA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgU3RlcCkpIHtcbiAgICAgIHN0ZXAgPSBuZXcgU3RlcCh0aGlzLCBzdGVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RlcC50b3VyID0gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGluZGV4KSkge1xuICAgICAgdGhpcy5zdGVwcy5zcGxpY2UoaW5kZXgsIDAsIHN0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0ZXBzLnB1c2goc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ZXA7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG11bHRpcGxlIHN0ZXBzIHRvIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0PiB8IEFycmF5PFN0ZXA+fSBzdGVwcyBUaGUgc3RlcHMgdG8gYWRkIHRvIHRoZSB0b3VyXG4gICAqL1xuICBhZGRTdGVwcyhzdGVwcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0ZXBzKSkge1xuICAgICAgc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byB0aGUgcHJldmlvdXMgc3RlcCBpbiB0aGUgdG91clxuICAgKi9cbiAgYmFjaygpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcbiAgICB0aGlzLnNob3coaW5kZXggLSAxLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgX2RvbmUoKSB0cmlnZ2VyaW5nIHRoZSAnY2FuY2VsJyBldmVudFxuICAgKiBJZiBgY29uZmlybUNhbmNlbGAgaXMgdHJ1ZSwgd2lsbCBzaG93IGEgd2luZG93LmNvbmZpcm0gYmVmb3JlIGNhbmNlbGxpbmdcbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbmZpcm1DYW5jZWwpIHtcbiAgICAgIGNvbnN0IGNhbmNlbE1lc3NhZ2UgPVxuICAgICAgICB0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbE1lc3NhZ2UgfHxcbiAgICAgICAgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBzdG9wIHRoZSB0b3VyPyc7XG4gICAgICBjb25zdCBzdG9wVG91ciA9IHdpbmRvdy5jb25maXJtKGNhbmNlbE1lc3NhZ2UpO1xuICAgICAgaWYgKHN0b3BUb3VyKSB7XG4gICAgICAgIHRoaXMuX2RvbmUoJ2NhbmNlbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kb25lKCdjYW5jZWwnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgX2RvbmUoKSB0cmlnZ2VyaW5nIHRoZSBgY29tcGxldGVgIGV2ZW50XG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLl9kb25lKCdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0ZXAgZnJvbSBhIGdpdmVuIGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBzdGVwIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBzdGVwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBpZGBcbiAgICovXG4gIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcy5maW5kKChzdGVwKSA9PiB7XG4gICAgICByZXR1cm4gc3RlcC5pZCA9PT0gaWQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzdGVwXG4gICAqIEByZXR1cm5zIHtTdGVwfG51bGx9XG4gICAqL1xuICBnZXRDdXJyZW50U3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjdXJyZW50IHN0ZXBcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgY29uc3QgY3VycmVudFN0ZXAgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCk7XG5cbiAgICBpZiAoY3VycmVudFN0ZXApIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RlcC5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0b3VyIGlzIGFjdGl2ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPT09IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR28gdG8gdGhlIG5leHQgc3RlcCBpbiB0aGUgdG91clxuICAgKiBJZiB3ZSBhcmUgYXQgdGhlIGVuZCwgY2FsbCBgY29tcGxldGVgXG4gICAqL1xuICBuZXh0KCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KGluZGV4ICsgMSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHN0ZXAgZnJvbSB0aGUgdG91clxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaWQgZm9yIHRoZSBzdGVwIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlU3RlcChuYW1lKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKTtcblxuICAgIC8vIEZpbmQgdGhlIHN0ZXAsIGRlc3Ryb3kgaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoaXMuc3RlcHNcbiAgICB0aGlzLnN0ZXBzLnNvbWUoKHN0ZXAsIGkpID0+IHtcbiAgICAgIGlmIChzdGVwLmlkID09PSBuYW1lKSB7XG4gICAgICAgIGlmIChzdGVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgc3RlcC5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGVwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGVwcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlkID09PSBuYW1lKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHN0ZXBzIGxlZnQsIHNob3cgdGhlIGZpcnN0IG9uZSwgb3RoZXJ3aXNlIGp1c3QgY2FuY2VsIHRoZSB0b3VyXG4gICAgICB0aGlzLnN0ZXBzLmxlbmd0aCA/IHRoaXMuc2hvdygwKSA6IHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgYSBzcGVjaWZpYyBzdGVwIGluIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IFRoZSBrZXkgdG8gbG9vayB1cCB0aGUgc3RlcCBieVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcndhcmQgVHJ1ZSBpZiB3ZSBhcmUgZ29pbmcgZm9yd2FyZCwgZmFsc2UgaWYgYmFja3dhcmRcbiAgICovXG4gIHNob3coa2V5ID0gMCwgZm9yd2FyZCA9IHRydWUpIHtcbiAgICBjb25zdCBzdGVwID0gaXNTdHJpbmcoa2V5KSA/IHRoaXMuZ2V0QnlJZChrZXkpIDogdGhpcy5zdGVwc1trZXldO1xuXG4gICAgaWYgKHN0ZXApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdygpO1xuXG4gICAgICBjb25zdCBzaG91bGRTa2lwU3RlcCA9XG4gICAgICAgIGlzRnVuY3Rpb24oc3RlcC5vcHRpb25zLnNob3dPbikgJiYgIXN0ZXAub3B0aW9ucy5zaG93T24oKTtcblxuICAgICAgLy8gSWYgYHNob3dPbmAgcmV0dXJucyBmYWxzZSwgd2Ugd2FudCB0byBza2lwIHRoZSBzdGVwLCBvdGhlcndpc2UsIHNob3cgdGhlIHN0ZXAgbGlrZSBub3JtYWxcbiAgICAgIGlmIChzaG91bGRTa2lwU3RlcCkge1xuICAgICAgICB0aGlzLl9za2lwU3RlcChzdGVwLCBmb3J3YXJkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignc2hvdycsIHtcbiAgICAgICAgICBzdGVwLFxuICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmN1cnJlbnRTdGVwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBzdGVwO1xuICAgICAgICBzdGVwLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHRvdXJcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMudHJpZ2dlcignc3RhcnQnKTtcblxuICAgIC8vIFNhdmUgdGhlIGZvY3VzZWQgZWxlbWVudCBiZWZvcmUgdGhlIHRvdXIgb3BlbnNcbiAgICB0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IG51bGw7XG5cbiAgICB0aGlzLl9zZXR1cE1vZGFsKCk7XG5cbiAgICB0aGlzLl9zZXR1cEFjdGl2ZVRvdXIoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHRvdXIgaXMgY2FuY2VsbGVkIG9yIGNvbXBsZXRlZCwgYmFzaWNhbGx5IGFueXRpbWUgd2UgZXhpdCB0aGUgdG91clxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUgdG8gdHJpZ2dlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvbmUoZXZlbnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0ZXBzKSkge1xuICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwKSA9PiBzdGVwLmRlc3Ryb3koKSk7XG4gICAgfVxuXG4gICAgY2xlYW51cFN0ZXBzKHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKGV2ZW50LCB7IGluZGV4IH0pO1xuXG4gICAgU2hlcGhlcmQuYWN0aXZlVG91ciA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VyKCdpbmFjdGl2ZScsIHsgdG91cjogdGhpcyB9KTtcblxuICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICB0aGlzLm1vZGFsLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgPT09ICdjYW5jZWwnIHx8IGV2ZW50ID09PSAnY29tcGxldGUnKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbCkge1xuICAgICAgICBjb25zdCBtb2RhbENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgJy5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lcidcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobW9kYWxDb250YWluZXIpIHtcbiAgICAgICAgICBtb2RhbENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvY3VzIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSB0b3VyIHN0YXJ0ZWRcbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4pKSB7XG4gICAgICB0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4uZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIHRvdXIgXCJhY3RpdmVcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwQWN0aXZlVG91cigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2FjdGl2ZScsIHsgdG91cjogdGhpcyB9KTtcblxuICAgIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIF9zZXR1cE1vZGFsIGNyZWF0ZSB0aGUgbW9kYWwgY29udGFpbmVyIGFuZCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwTW9kYWwoKSB7XG4gICAgdGhpcy5tb2RhbCA9IG5ldyBTaGVwaGVyZE1vZGFsKHtcbiAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLm1vZGFsQ29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbGFzc1ByZWZpeDogdGhpcy5jbGFzc1ByZWZpeCxcbiAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGBzaG93T25gIGV2YWx1YXRlcyB0byBmYWxzZSwgdG8gc2tpcCB0aGUgc3RlcCBvciBjb21wbGV0ZSB0aGUgdG91ciBpZiBpdCdzIHRoZSBsYXN0IHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIHRvIHNraXBcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3J3YXJkIFRydWUgaWYgd2UgYXJlIGdvaW5nIGZvcndhcmQsIGZhbHNlIGlmIGJhY2t3YXJkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2tpcFN0ZXAoc3RlcCwgZm9yd2FyZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHN0ZXApO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV4dEluZGV4ID0gZm9yd2FyZCA/IGluZGV4ICsgMSA6IGluZGV4IC0gMTtcbiAgICAgIHRoaXMuc2hvdyhuZXh0SW5kZXgsIGZvcndhcmQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgc2hvd2luZywgaGlkZSB0aGUgY3VycmVudCBzdGVwIGFuZCBpZiB0aGUgdG91ciBpcyBub3RcbiAgICogYWxyZWFkeSBhY3RpdmUsIGNhbGwgYHRoaXMuX3NldHVwQWN0aXZlVG91cmAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3RhdGVCZWZvcmVTaG93KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTdGVwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fc2V0dXBBY3RpdmVUb3VyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcy5pZCB0byBgJHt0b3VyTmFtZX0tLSR7dXVpZH1gXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VG91cklEKCkge1xuICAgIGNvbnN0IHRvdXJOYW1lID0gdGhpcy5vcHRpb25zLnRvdXJOYW1lIHx8ICd0b3VyJztcblxuICAgIHRoaXMuaWQgPSBgJHt0b3VyTmFtZX0tLSR7dXVpZCgpfWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcbiIsImltcG9ydCB7IFN0ZXAgfSBmcm9tICcuL3N0ZXAuanMnO1xuaW1wb3J0IHsgU2hlcGhlcmQsIFRvdXIgfSBmcm9tICcuL3RvdXIuanMnO1xuXG5PYmplY3QuYXNzaWduKFNoZXBoZXJkLCB7IFRvdXIsIFN0ZXAgfSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNoZXBoZXJkO1xuIl0sIm5hbWVzIjpbImlzTWVyZ2VhYmxlT2JqZWN0IiwidmFsdWUiLCJpc05vbk51bGxPYmplY3QiLCJpc1NwZWNpYWwiLCJfdHlwZW9mIiwic3RyaW5nVmFsdWUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1JlYWN0RWxlbWVudCIsImNhblVzZVN5bWJvbCIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIiQkdHlwZW9mIiwiZW1wdHlUYXJnZXQiLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCIsIm9wdGlvbnMiLCJjbG9uZSIsImRlZXBtZXJnZSIsImRlZmF1bHRBcnJheU1lcmdlIiwidGFyZ2V0Iiwic291cmNlIiwiY29uY2F0IiwibWFwIiwiZWxlbWVudCIsImdldE1lcmdlRnVuY3Rpb24iLCJrZXkiLCJjdXN0b21NZXJnZSIsImdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJzeW1ib2wiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldEtleXMiLCJrZXlzIiwicHJvcGVydHlJc09uT2JqZWN0Iiwib2JqZWN0IiwicHJvcGVydHkiLCJfIiwicHJvcGVydHlJc1Vuc2FmZSIsImhhc093blByb3BlcnR5IiwibWVyZ2VPYmplY3QiLCJkZXN0aW5hdGlvbiIsImZvckVhY2giLCJhcnJheU1lcmdlIiwic291cmNlSXNBcnJheSIsInRhcmdldElzQXJyYXkiLCJzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoIiwiYWxsIiwiZGVlcG1lcmdlQWxsIiwiYXJyYXkiLCJFcnJvciIsInJlZHVjZSIsInByZXYiLCJuZXh0IiwiZGVlcG1lcmdlXzEiLCJjanMiLCJpc0VsZW1lbnQiLCJpc0VsZW1lbnQkMSIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiaXNIVE1MRWxlbWVudCQxIiwiSFRNTEVsZW1lbnQiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc1VuZGVmaW5lZCIsInVuZGVmaW5lZCIsIkV2ZW50ZWQiLCJfY2xhc3NDYWxsQ2hlY2siLCJfY3JlYXRlQ2xhc3MiLCJvbiIsImV2ZW50IiwiaGFuZGxlciIsImN0eCIsIm9uY2UiLCJiaW5kaW5ncyIsInB1c2giLCJvZmYiLCJfdGhpcyIsImJpbmRpbmciLCJpbmRleCIsInNwbGljZSIsInRyaWdnZXIiLCJfdGhpczIiLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIl9rZXkiLCJjb250ZXh0IiwiYXBwbHkiLCJhdXRvQmluZCIsInNlbGYiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY29uc3RydWN0b3IiLCJpIiwiYmluZCIsIl9zZXR1cEFkdmFuY2VPbkhhbmRsZXIiLCJzZWxlY3RvciIsInN0ZXAiLCJpc09wZW4iLCJ0YXJnZXRJc0VsIiwiZWwiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0SXNTZWxlY3RvciIsIm1hdGNoZXMiLCJ0b3VyIiwiYmluZEFkdmFuY2UiLCJfcmVmNiIsImFkdmFuY2VPbiIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImJvZHkiLCJ0b3AiLCJib3R0b20iLCJyaWdodCIsImxlZnQiLCJhdXRvIiwiYmFzZVBsYWNlbWVudHMiLCJzdGFydCIsImVuZCIsImNsaXBwaW5nUGFyZW50cyIsInZpZXdwb3J0IiwicG9wcGVyIiwicmVmZXJlbmNlIiwidmFyaWF0aW9uUGxhY2VtZW50cyIsImFjYyIsInBsYWNlbWVudCIsInBsYWNlbWVudHMiLCJiZWZvcmVSZWFkIiwicmVhZCIsImFmdGVyUmVhZCIsImJlZm9yZU1haW4iLCJtYWluIiwiYWZ0ZXJNYWluIiwiYmVmb3JlV3JpdGUiLCJ3cml0ZSIsImFmdGVyV3JpdGUiLCJtb2RpZmllclBoYXNlcyIsImdldE5vZGVOYW1lIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdldFdpbmRvdyIsIm5vZGUiLCJ3aW5kb3ciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJPd25FbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImFwcGx5U3R5bGVzIiwiX3JlZiIsInN0YXRlIiwiZWxlbWVudHMiLCJuYW1lIiwic3R5bGUiLCJzdHlsZXMiLCJhdHRyaWJ1dGVzIiwiYXNzaWduIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZWZmZWN0IiwiZWZmZWN0JDIiLCJfcmVmMiIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsInN0cmF0ZWd5IiwibWFyZ2luIiwiYXJyb3ciLCJzdHlsZVByb3BlcnRpZXMiLCJhdHRyaWJ1dGUiLCJhcHBseVN0eWxlcyQxIiwiZW5hYmxlZCIsInBoYXNlIiwiZm4iLCJyZXF1aXJlcyIsImdldEJhc2VQbGFjZW1lbnQiLCJzcGxpdCIsIm1heCIsIk1hdGgiLCJtaW4iLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImluY2x1ZGVTY2FsZSIsInJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIndpZHRoIiwiaGVpZ2h0IiwieCIsInkiLCJnZXRMYXlvdXRSZWN0IiwiY2xpZW50UmVjdCIsImFicyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJjb250YWlucyIsInBhcmVudCIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsImlzU2FtZU5vZGUiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldENvbXB1dGVkU3R5bGUiLCJpc1RhYmxlRWxlbWVudCIsImluZGV4T2YiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50Iiwid2l0aGluIiwibWF0aE1heCIsIm1hdGhNaW4iLCJ3aXRoaW5NYXhDbGFtcCIsInYiLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsInRvUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJyZWN0cyIsIl9zdGF0ZSRtb2RpZmllcnNEYXRhJCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJtb2RpZmllcnNEYXRhIiwiYmFzZVBsYWNlbWVudCIsImF4aXMiLCJpc1ZlcnRpY2FsIiwibGVuIiwiYXJyb3dSZWN0IiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsImF4aXNQcm9wIiwiY2VudGVyT2Zmc2V0IiwiZWZmZWN0JDEiLCJfb3B0aW9ucyRlbGVtZW50IiwiYXJyb3ckMSIsInJlcXVpcmVzSWZFeGlzdHMiLCJnZXRWYXJpYXRpb24iLCJ1bnNldFNpZGVzIiwicm91bmRPZmZzZXRzQnlEUFIiLCJ3aW4iLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFwVG9TdHlsZXMiLCJfT2JqZWN0JGFzc2lnbjIiLCJwb3BwZXJSZWN0IiwidmFyaWF0aW9uIiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiaXNGaXhlZCIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwib2Zmc2V0WSIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0WCIsImNvbW1vblN0eWxlcyIsIl9yZWY0IiwiX09iamVjdCRhc3NpZ24iLCJjb21wdXRlU3R5bGVzIiwiX3JlZjUiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsImNvbXB1dGVTdHlsZXMkMSIsImRhdGEiLCJwYXNzaXZlIiwiaW5zdGFuY2UiLCJfb3B0aW9ucyRzY3JvbGwiLCJzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJzY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50IiwidXBkYXRlIiwiZXZlbnRMaXN0ZW5lcnMiLCJoYXNoIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJyZXBsYWNlIiwibWF0Y2hlZCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiZ2V0V2luZG93U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Vmlld3BvcnRSZWN0IiwiaHRtbCIsInRlc3QiLCJnZXREb2N1bWVudFJlY3QiLCJfZWxlbWVudCRvd25lckRvY3VtZW4iLCJ3aW5TY3JvbGwiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldFNjcm9sbFBhcmVudCIsImxpc3RTY3JvbGxQYXJlbnRzIiwibGlzdCIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwicmVjdFRvQ2xpZW50UmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlIiwiY2xpcHBpbmdQYXJlbnQiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiZmlyc3RDbGlwcGluZ1BhcmVudCIsImNsaXBwaW5nUmVjdCIsImFjY1JlY3QiLCJjb21wdXRlT2Zmc2V0cyIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJkZXRlY3RPdmVyZmxvdyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwiZmxpcFZhcmlhdGlvbnMiLCJfb3B0aW9ucyRhbGxvd2VkQXV0b1AiLCJhbGxvd2VkQXV0b1BsYWNlbWVudHMiLCJhbGxQbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHMiLCJvdmVyZmxvd3MiLCJzb3J0IiwiYSIsImIiLCJnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZmxpcCIsIl9za2lwIiwiX29wdGlvbnMkbWFpbkF4aXMiLCJjaGVja01haW5BeGlzIiwiX29wdGlvbnMkYWx0QXhpcyIsImFsdEF4aXMiLCJjaGVja0FsdEF4aXMiLCJzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMiLCJmYWxsYmFja1BsYWNlbWVudHMiLCJfb3B0aW9ucyRmbGlwVmFyaWF0aW8iLCJwcmVmZXJyZWRQbGFjZW1lbnQiLCJpc0Jhc2VQbGFjZW1lbnQiLCJyZWZlcmVuY2VSZWN0IiwiY2hlY2tzTWFwIiwiTWFwIiwibWFrZUZhbGxiYWNrQ2hlY2tzIiwiZmlyc3RGaXR0aW5nUGxhY2VtZW50IiwiX2Jhc2VQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwibWFpblZhcmlhdGlvblNpZGUiLCJhbHRWYXJpYXRpb25TaWRlIiwiY2hlY2tzIiwiZXZlcnkiLCJjaGVjayIsInNldCIsIm51bWJlck9mQ2hlY2tzIiwiX2xvb3AiLCJfaSIsImZpdHRpbmdQbGFjZW1lbnQiLCJmaW5kIiwiZ2V0Iiwic2xpY2UiLCJfcmV0IiwicmVzZXQiLCJmbGlwJDEiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzb21lIiwic2lkZSIsImhpZGUiLCJwcmV2ZW50T3ZlcmZsb3ciLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImhpZGUkMSIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50Iiwib2Zmc2V0JDEiLCJwb3BwZXJPZmZzZXRzJDEiLCJnZXRBbHRBeGlzIiwiX29wdGlvbnMkdGV0aGVyIiwidGV0aGVyIiwiX29wdGlvbnMkdGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0IiwidGV0aGVyT2Zmc2V0VmFsdWUiLCJub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUiLCJvZmZzZXRNb2RpZmllclN0YXRlIiwiX29mZnNldE1vZGlmaWVyU3RhdGUkIiwibWFpblNpZGUiLCJhbHRTaWRlIiwiYWRkaXRpdmUiLCJtaW5MZW4iLCJtYXhMZW4iLCJhcnJvd1BhZGRpbmdPYmplY3QiLCJhcnJvd1BhZGRpbmdNaW4iLCJhcnJvd1BhZGRpbmdNYXgiLCJhcnJvd0xlbiIsIm1pbk9mZnNldCIsIm1heE9mZnNldCIsImNsaWVudE9mZnNldCIsIm9mZnNldE1vZGlmaWVyVmFsdWUiLCJ0ZXRoZXJNaW4iLCJ0ZXRoZXJNYXgiLCJwcmV2ZW50ZWRPZmZzZXQiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIiwiX21haW5TaWRlIiwiX2FsdFNpZGUiLCJfb2Zmc2V0IiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiaXNFbGVtZW50U2NhbGVkIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm9yZGVyIiwibW9kaWZpZXJzIiwidmlzaXRlZCIsIlNldCIsInJlc3VsdCIsIm1vZGlmaWVyIiwiYWRkIiwiZGVwIiwiaGFzIiwiZGVwTW9kaWZpZXIiLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJtZXJnZUJ5TmFtZSIsIm1lcmdlZCIsImN1cnJlbnQiLCJleGlzdGluZyIsIkRFRkFVTFRfT1BUSU9OUyIsImFyZVZhbGlkRWxlbWVudHMiLCJwb3BwZXJHZW5lcmF0b3IiLCJnZW5lcmF0b3JPcHRpb25zIiwiX2dlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYiLCJkZWZhdWx0TW9kaWZpZXJzIiwiX2dlbmVyYXRvck9wdGlvbnMkZGVmMiIsImRlZmF1bHRPcHRpb25zIiwiY3JlYXRlUG9wcGVyIiwiZWZmZWN0Q2xlYW51cEZucyIsImlzRGVzdHJveWVkIiwic2V0T3B0aW9ucyIsInNldE9wdGlvbnNBY3Rpb24iLCJjbGVhbnVwTW9kaWZpZXJFZmZlY3RzIiwibSIsInJ1bk1vZGlmaWVyRWZmZWN0cyIsImZvcmNlVXBkYXRlIiwiX3N0YXRlJGVsZW1lbnRzIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllIiwiX3N0YXRlJG9yZGVyZWRNb2RpZmllMiIsImRlc3Ryb3kiLCJvbkZpcnN0VXBkYXRlIiwiX3JlZjMkb3B0aW9ucyIsImNsZWFudXBGbiIsIm5vb3BGbiIsIl9nZXRDZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIiLCJnZW5lcmF0ZUZvY3VzQWZ0ZXJSZW5kZXJNb2RpZmllciIsInNldFRpbWVvdXQiLCJmb2N1c09wdGlvbnMiLCJwcmV2ZW50U2Nyb2xsIiwiZm9jdXMiLCJtYWtlQ2VudGVyZWRQb3BwZXIiLCJjZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIiLCJwb3BwZXJPcHRpb25zIiwiX2V4dGVuZHMiLCJmcm9tIiwiX3RvQ29uc3VtYWJsZUFycmF5Iiwibm9ybWFsaXplUHJlZml4IiwicHJlZml4IiwiY2hhckF0IiwicGFyc2VBdHRhY2hUbyIsImF0dGFjaFRvIiwicmV0dXJuT3B0cyIsInNob3VsZENlbnRlclN0ZXAiLCJyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyIsInNldHVwVG9vbHRpcCIsInRvb2x0aXAiLCJhdHRhY2hUb09wdGlvbnMiLCJfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMiLCJnZXRQb3BwZXJPcHRpb25zIiwiY29udGVudCIsInNoZXBoZXJkRWxlbWVudENvbXBvbmVudCIsImdldEVsZW1lbnQiLCJjbGFzc0xpc3QiLCJ1dWlkIiwiZCIsIkRhdGUiLCJub3ciLCJjIiwiciIsInJhbmRvbSIsImZsb29yIiwiZGVmYXVsdFN0ZXBPcHRpb25zIiwiX21lcmdlTW9kaWZpZXJzIiwic3RlcE9wdGlvbnMiLCJtZXJnZWRQb3BwZXJPcHRpb25zIiwibmFtZXMiLCJtb2QiLCJmaWx0ZXJlZE1vZGlmaWVycyIsImluY2x1ZGVzIiwibm9vcCIsInRhciIsInNyYyIsImsiLCJydW4iLCJibGFua19vYmplY3QiLCJjcmVhdGUiLCJydW5fYWxsIiwiZm5zIiwiaXNfZnVuY3Rpb24iLCJ0aGluZyIsInNhZmVfbm90X2VxdWFsIiwiaXNfZW1wdHkiLCJvYmoiLCJhcHBlbmQiLCJhcHBlbmRDaGlsZCIsImluc2VydCIsImFuY2hvciIsImluc2VydEJlZm9yZSIsImRldGFjaCIsInJlbW92ZUNoaWxkIiwiZGVzdHJveV9lYWNoIiwiaXRlcmF0aW9ucyIsImRldGFjaGluZyIsImNyZWF0ZUVsZW1lbnQiLCJzdmdfZWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsInRleHQiLCJjcmVhdGVUZXh0Tm9kZSIsInNwYWNlIiwiZW1wdHkiLCJsaXN0ZW4iLCJhdHRyIiwiZ2V0QXR0cmlidXRlIiwic2V0X2F0dHJpYnV0ZXMiLCJkZXNjcmlwdG9ycyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJfX3Byb3RvX18iLCJjc3NUZXh0IiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwidG9nZ2xlX2NsYXNzIiwidG9nZ2xlIiwiY3VycmVudF9jb21wb25lbnQiLCJzZXRfY3VycmVudF9jb21wb25lbnQiLCJjb21wb25lbnQiLCJnZXRfY3VycmVudF9jb21wb25lbnQiLCJvbk1vdW50IiwiJCQiLCJvbl9tb3VudCIsImFmdGVyVXBkYXRlIiwiYWZ0ZXJfdXBkYXRlIiwiZGlydHlfY29tcG9uZW50cyIsImJpbmRpbmdfY2FsbGJhY2tzIiwicmVuZGVyX2NhbGxiYWNrcyIsImZsdXNoX2NhbGxiYWNrcyIsInJlc29sdmVkX3Byb21pc2UiLCJ1cGRhdGVfc2NoZWR1bGVkIiwic2NoZWR1bGVfdXBkYXRlIiwiZmx1c2giLCJhZGRfcmVuZGVyX2NhbGxiYWNrIiwic2Vlbl9jYWxsYmFja3MiLCJmbHVzaGlkeCIsInNhdmVkX2NvbXBvbmVudCIsInBvcCIsImNhbGxiYWNrIiwiY2xlYXIiLCJmcmFnbWVudCIsImJlZm9yZV91cGRhdGUiLCJkaXJ0eSIsInAiLCJvdXRyb2luZyIsIm91dHJvcyIsImdyb3VwX291dHJvcyIsImNoZWNrX291dHJvcyIsInRyYW5zaXRpb25faW4iLCJibG9jayIsImxvY2FsIiwiZGVsZXRlIiwidHJhbnNpdGlvbl9vdXQiLCJvIiwiZ2V0X3NwcmVhZF91cGRhdGUiLCJsZXZlbHMiLCJ1cGRhdGVzIiwidG9fbnVsbF9vdXQiLCJhY2NvdW50ZWRfZm9yIiwiJCRzY29wZSIsIm4iLCJjcmVhdGVfY29tcG9uZW50IiwibW91bnRfY29tcG9uZW50IiwiY3VzdG9tRWxlbWVudCIsIl9jb21wb25lbnQkJCQiLCJvbl9kZXN0cm95IiwibmV3X29uX2Rlc3Ryb3kiLCJkZXN0cm95X2NvbXBvbmVudCIsIm1ha2VfZGlydHkiLCJmaWxsIiwiaW5pdCIsImNyZWF0ZV9mcmFnbWVudCIsIm5vdF9lcXVhbCIsInByb3BzIiwiYXBwZW5kX3N0eWxlcyIsInBhcmVudF9jb21wb25lbnQiLCJib3VuZCIsIm9uX2Rpc2Nvbm5lY3QiLCJjYWxsYmFja3MiLCJza2lwX2JvdW5kIiwicm9vdCIsInJlYWR5IiwicmV0IiwiaHlkcmF0ZSIsIm5vZGVzIiwibCIsImludHJvIiwiU3ZlbHRlQ29tcG9uZW50IiwiJGRlc3Ryb3kiLCIkb24iLCJ0eXBlIiwiJHNldCIsIiQkcHJvcHMiLCIkJHNldCIsImJ1dHRvbiIsImJ1dHRvbl9jbGFzc192YWx1ZSIsImNvbmZpZyIsImFjdGlvbiIsImNsYXNzZXMiLCJkaXNhYmxlZCIsImxhYmVsIiwic2Vjb25kYXJ5IiwiZ2V0Q29uZmlnT3B0aW9uIiwib3B0aW9uIiwiJCRpbnZhbGlkYXRlIiwiZWFjaF9ibG9ja3MiLCJjcmVhdGVfaWZfYmxvY2siLCJmb290ZXIiLCIkIiwiYnV0dG9ucyIsImJ1dHRvbl9hcmlhX2xhYmVsX3ZhbHVlIiwic3BhbiIsImNhbmNlbEljb24iLCJoYW5kbGVDYW5jZWxDbGljayIsInByZXZlbnREZWZhdWx0IiwiY2FuY2VsIiwiaDMiLCJsYWJlbElkIiwidGl0bGUiLCJpbm5lckhUTUwiLCIkJHZhbHVlIiwiY3JlYXRlX2lmX2Jsb2NrXzEiLCJoZWFkZXIiLCJkaXYiLCJkZXNjcmlwdGlvbklkIiwic2hvd19pZl8yIiwic2hvd19pZl8xIiwic2hvd19pZiIsImRpdl9hcmlhX2Rlc2NyaWJlZGJ5X3ZhbHVlIiwiS0VZX1RBQiIsIktFWV9FU0MiLCJMRUZUX0FSUk9XIiwiUklHSFRfQVJST1ciLCJnZXRDbGFzc2VzQXJyYXkiLCJjbGFzc05hbWUiLCJjbGFzc1ByZWZpeCIsImZpcnN0Rm9jdXNhYmxlRWxlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwibGFzdEZvY3VzYWJsZUVsZW1lbnQiLCJkYXRhU3RlcElkIiwiaGFzQ2FuY2VsSWNvbiIsImhhc1RpdGxlIiwiX2RlZmluZVByb3BlcnR5IiwiaWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwidXBkYXRlRHluYW1pY0NsYXNzZXMiLCJyZW1vdmVDbGFzc2VzIiwiYWRkQ2xhc3NlcyIsIm9sZENsYXNzZXMiLCJfZWxlbWVudCRjbGFzc0xpc3QiLCJyZW1vdmUiLCJuZXdDbGFzc2VzIiwiX2VsZW1lbnQkY2xhc3NMaXN0MiIsImhhbmRsZUtleURvd24iLCJfc3RlcCIsImtleUNvZGUiLCJzaGlmdEtleSIsImFjdGl2ZUVsZW1lbnQiLCJleGl0T25Fc2MiLCJrZXlib2FyZE5hdmlnYXRpb24iLCJiYWNrIiwicG9seWZpbGwiLCJ3IiwiX19mb3JjZVNtb290aFNjcm9sbFBvbHlmaWxsX18iLCJTQ1JPTExfVElNRSIsIm9yaWdpbmFsIiwic2Nyb2xsVG8iLCJzY3JvbGxCeSIsImVsZW1lbnRTY3JvbGwiLCJzY3JvbGxFbGVtZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJwZXJmb3JtYW5jZSIsImlzTWljcm9zb2Z0QnJvd3NlciIsInVzZXJBZ2VudFBhdHRlcm5zIiwiUmVnRXhwIiwiam9pbiIsIlJPVU5ESU5HX1RPTEVSQU5DRSIsImVhc2UiLCJjb3MiLCJQSSIsInNob3VsZEJhaWxPdXQiLCJmaXJzdEFyZyIsImJlaGF2aW9yIiwiVHlwZUVycm9yIiwiaGFzU2Nyb2xsYWJsZVNwYWNlIiwiY2FuT3ZlcmZsb3ciLCJvdmVyZmxvd1ZhbHVlIiwiaXNTY3JvbGxhYmxlIiwiaXNTY3JvbGxhYmxlWSIsImlzU2Nyb2xsYWJsZVgiLCJmaW5kU2Nyb2xsYWJsZVBhcmVudCIsInRpbWUiLCJjdXJyZW50WCIsImN1cnJlbnRZIiwiZWxhcHNlZCIsInN0YXJ0VGltZSIsInN0YXJ0WCIsInN0YXJ0WSIsIm1ldGhvZCIsInNjcm9sbGFibGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzbW9vdGhTY3JvbGwiLCJzY3JvbGxYIiwic2Nyb2xsWSIsIlN5bnRheEVycm9yIiwic2Nyb2xsYWJsZVBhcmVudCIsInBhcmVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJtb2R1bGUiLCJzbW9vdGhzY3JvbGwiLCJTdGVwIiwiX0V2ZW50ZWQiLCJfaW5oZXJpdHMiLCJfc3VwZXI5IiwiX2NyZWF0ZVN1cGVyIiwiX3RoaXMxMSIsIl9yZXNvbHZlZEF0dGFjaFRvIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIl9zZXRPcHRpb25zIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJjb21wbGV0ZSIsIl91cGRhdGVTdGVwVGFyZ2V0T25IaWRlIiwiZ2V0VG91ciIsIm1vZGFsIiwiaGlkZGVuIiwiX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMiLCJCb29sZWFuIiwic2hvdyIsIl90aGlzMTIiLCJiZWZvcmVTaG93UHJvbWlzZSIsIl9zaG93IiwidXBkYXRlU3RlcE9wdGlvbnMiLCJnZXRUYXJnZXQiLCJfY3JlYXRlVG9vbHRpcENvbnRlbnQiLCJTaGVwaGVyZEVsZW1lbnQiLCJzdGVwc0NvbnRhaW5lciIsIl9zY3JvbGxUbyIsInNjcm9sbFRvT3B0aW9ucyIsIl90aGlzJF9nZXRSZXNvbHZlZEF0dCIsInNjcm9sbFRvSGFuZGxlciIsIl9nZXRDbGFzc09wdGlvbnMiLCJzdGVwQ2xhc3NlcyIsImRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwidW5pcUNsYXNzZXMiLCJ0cmltIiwiX3RoaXMxMyIsInRvdXJPcHRpb25zIiwibWVyZ2UiLCJ3aGVuIiwiX3NldHVwRWxlbWVudHMiLCJfdGhpczE0IiwiX3NldHVwTW9kYWwiLCJzZXR1cEZvclN0ZXAiLCJfc3R5bGVUYXJnZXRFbGVtZW50Rm9yU3RlcCIsInRhcmdldEVsZW1lbnQiLCJoaWdobGlnaHRDbGFzcyIsImNhbkNsaWNrVGFyZ2V0IiwiY2xlYW51cFN0ZXBzIiwic3RlcHMiLCJtYWtlT3ZlcmxheVBhdGgiLCJfcmVmJHgiLCJfcmVmJHkiLCJfcmVmJHIiLCJfd2luZG93IiwiaW5uZXJXaWR0aCIsImgiLCJpbm5lckhlaWdodCIsInN2ZyIsInBhdGgiLCJfZ2V0U2Nyb2xsUGFyZW50IiwiaXNIdG1sRWxlbWVudCIsInBhcmVudEVsZW1lbnQiLCJfZ2V0VmlzaWJsZUhlaWdodCIsImVsZW1lbnRSZWN0Iiwic2Nyb2xsUmVjdCIsInNjcm9sbEJvdHRvbSIsIm9wZW5pbmdQcm9wZXJ0aWVzIiwibW9kYWxJc1Zpc2libGUiLCJyYWZJZCIsInBhdGhEZWZpbml0aW9uIiwiY2xvc2VNb2RhbE9wZW5pbmciLCJfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycyIsInBvc2l0aW9uTW9kYWwiLCJtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyIsIm1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMiLCJfZ2V0VmlzaWJsZUhlaWdodDIiLCJfdGFyZ2V0RWxlbWVudCRnZXRCb3UiLCJ1c2VNb2RhbE92ZXJsYXkiLCJfc3R5bGVGb3JTdGVwIiwiX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCIsIl9wcmV2ZW50TW9kYWxPdmVybGF5VG91Y2giLCJzdG9wUHJvcGFnYXRpb24iLCJfYWRkU3RlcEV2ZW50TGlzdGVuZXJzIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJfc3RlcCRvcHRpb25zIiwicmFmTG9vcCIsIlNoZXBoZXJkIiwiVG91ciIsIl9FdmVudGVkMiIsIl9zdXBlcjExIiwiX3RoaXMxNiIsImRlZmF1bHRUb3VyT3B0aW9ucyIsImFkZFN0ZXBzIiwiZXZlbnRzIiwib3B0cyIsIl9zZXRUb3VySUQiLCJhZGRTdGVwIiwiX3RoaXMxNyIsImN1cnJlbnRTdGVwIiwiY29uZmlybUNhbmNlbCIsImNhbmNlbE1lc3NhZ2UiLCJjb25maXJtQ2FuY2VsTWVzc2FnZSIsInN0b3BUb3VyIiwiY29uZmlybSIsIl9kb25lIiwiZ2V0QnlJZCIsImdldEN1cnJlbnRTdGVwIiwiaXNBY3RpdmUiLCJhY3RpdmVUb3VyIiwicmVtb3ZlU3RlcCIsIl90aGlzMTgiLCJmb3J3YXJkIiwiX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdyIsInNob3VsZFNraXBTdGVwIiwic2hvd09uIiwiX3NraXBTdGVwIiwicHJldmlvdXMiLCJmb2N1c2VkRWxCZWZvcmVPcGVuIiwiX3NldHVwQWN0aXZlVG91ciIsIm1vZGFsQ29udGFpbmVyIiwiU2hlcGhlcmRNb2RhbCIsIm5leHRJbmRleCIsInRvdXJOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/shepherd/shepherd.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});